-- Automatically generated by ForSyDe
library forsyde;
library ieee;
use forsyde.types.all;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library aluProc_lib;
use aluProc_lib.types.all;


entity \aluProc\ is
     port (\sel\ : in fsvec_2_std_logic;
           \a\ : in fsvec_4_std_logic;
           \b\ : in fsvec_4_std_logic;
           \cout\ : out std_logic;
           \data\ : out fsvec_4_std_logic);
end entity \aluProc\;


architecture synthesizable of \aluProc\ is
     signal \add_out1\ : std_logic;
     signal \add_out2\ : fsvec_4_std_logic;
     signal \and_out1\ : fsvec_4_std_logic;
     signal \or_out1\ : fsvec_4_std_logic;
     signal \lsl_out1\ : fsvec_4_std_logic;
     signal \mux_out1\ : fsvec_4_std_logic;
begin
     \add\ : entity work.\add4FSVecProc\
                  port map (\a\ => \a\,
                            \b\ => \b\,
                            \cout\ => \add_out1\,
                            \sum\ => \add_out2\);
     
     \and\ : entity work.\and4BitProc\
                  port map (\a\ => \a\,
                            \b\ => \b\,
                            \y\ => \and_out1\);
     
     \or\ : entity work.\or4BitProc\
                 port map (\a\ => \a\,
                           \b\ => \b\,
                           \y\ => \or_out1\);
     
     \lsl\ : entity work.\lslProc\
                  port map (\in\ => \a\,
                            \out\ => \lsl_out1\);
     
     \mux\ : entity work.\mux41Proc\
                  port map (\sel\ => \sel\,
                            \d3\ => \and_out1\,
                            \d2\ => \or_out1\,
                            \d1\ => \add_out2\,
                            \d0\ => \lsl_out1\,
                            \out\ => \mux_out1\);
     
     \cout\ <= \add_out1\;
     
     \data\ <= \mux_out1\;
end architecture synthesizable;
