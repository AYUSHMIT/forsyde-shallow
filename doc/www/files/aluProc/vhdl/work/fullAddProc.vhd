-- Automatically generated by ForSyDe
library forsyde;
library ieee;
use forsyde.types.all;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library aluProc_lib;
use aluProc_lib.types.all;


entity \fullAddProc\ is
     port (\a\ : in std_logic;
           \b\ : in std_logic;
           \c_in\ : in std_logic;
           \cout\ : out std_logic;
           \sum\ : out std_logic);
end entity \fullAddProc\;


architecture synthesizable of \fullAddProc\ is
     signal \fulladd_out\ : tup_2_std_logic_std_logic;
     signal \unzipSY_out1\ : std_logic;
     signal \unzipSY_out2\ : std_logic;
begin
     \fulladd\ : block
          port (\fulladd_in1\ : in std_logic;
                \fulladd_in2\ : in std_logic;
                \fulladd_in3\ : in std_logic;
                \fulladd_out\ : out tup_2_std_logic_std_logic);
          port map (\fulladd_in1\ => \a\,
                    \fulladd_in2\ => \b\,
                    \fulladd_in3\ => \c_in\,
                    \fulladd_out\ => \fulladd_out\);
          function \fullAddFun\ (\a\ : std_logic;
                                 \b\ : std_logic;
                                 \c_in\ : std_logic)
                                return tup_2_std_logic_std_logic is
          begin
               return ((\a\ and \b\) or (\a\ and \c_in\) or
                       (\b\ and \c_in\), \a\ xor \b\ xor \c_in\);
          end;
     begin
          \fulladd_out\ <= \fullAddFun\(\a\ => \a\,
                                        \b\ => \b\,
                                        \c_in\ => \c_in\);
     end block \fulladd\;
     
     \unzipSY\ : block
          port (\unzipSY_in\ : in tup_2_std_logic_std_logic;
                \unzipSY_out1\ : out std_logic;
                \unzipSY_out2\ : out std_logic);
          port map (\unzipSY_in\ => \fulladd_out\,
                    \unzipSY_out1\ => \unzipSY_out1\,
                    \unzipSY_out2\ => \unzipSY_out2\);
     begin
          \unzipSY_out1\ <= \unzipSY_in\.tup_1;
          \unzipSY_out2\ <= \unzipSY_in\.tup_2;
     end block \unzipSY\;
     
     \cout\ <= \unzipSY_out1\;
     
     \sum\ <= \unzipSY_out2\;
end architecture synthesizable;
