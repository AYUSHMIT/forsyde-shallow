-- Automatically generated by ForSyDe
library forsyde;
library ieee;
use forsyde.types.all;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library aluProc_lib;
use aluProc_lib.types.all;


entity \convToFSVec4Proc\ is
     port (\x3\ : in std_logic;
           \x2\ : in std_logic;
           \x1\ : in std_logic;
           \x0\ : in std_logic;
           \vec4\ : out fsvec_4_std_logic);
end entity \convToFSVec4Proc\;


architecture synthesizable of \convToFSVec4Proc\ is
     signal \toVector4_out\ : fsvec_4_std_logic;
begin
     \toVector4\ : block
          port (\toVector4_in1\ : in std_logic;
                \toVector4_in2\ : in std_logic;
                \toVector4_in3\ : in std_logic;
                \toVector4_in4\ : in std_logic;
                \toVector4_out\ : out fsvec_4_std_logic);
          port map (\toVector4_in1\ => \x3\,
                    \toVector4_in2\ => \x2\,
                    \toVector4_in3\ => \x1\,
                    \toVector4_in4\ => \x0\,
                    \toVector4_out\ => \toVector4_out\);
          function \convToFSVec4Fun\ (\x3\ : std_logic;
                                      \x2\ : std_logic;
                                      \x1\ : std_logic;
                                      \x0\ : std_logic)
                                     return fsvec_4_std_logic is
          begin
               return plusgt(\x3\,
                             plusgt(\x2\, plusgt(\x1\, plusgt(\x0\, empty))));
          end;
     begin
          \toVector4_out\ <= \convToFSVec4Fun\(\x3\ => \x3\,
                                               \x2\ => \x2\,
                                               \x1\ => \x1\,
                                               \x0\ => \x0\);
     end block \toVector4\;
     
     \vec4\ <= \toVector4_out\;
end architecture synthesizable;
