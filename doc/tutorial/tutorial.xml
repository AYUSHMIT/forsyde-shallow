<?xml version="1.0" encoding="UTF-8"?>
<article xml:id="ForSyDe-tutorial" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>ForSyDe tutorial</title>
    <author>
      <personname>
	<firstname>Alfonso</firstname><surname>Acosta</surname>
      </personname>
      <affiliation>
	<org>
	  <orgname>Royal Institute of Technology (KTH)</orgname>
	  <orgdiv>System, Architecture and Methodology (SAM) group</orgdiv>
	  <address><city>Stockholm</city>, <country>Sweden</country></address>
	</org>
      </affiliation>
      <email>alfonsoa@kth.se</email>
    </author>  
    <authorinitials>aag</authorinitials>
    <pubdate>2008-09-20</pubdate>
    <revhistory>
      <revision>
	<revnumber>0.2</revnumber>
	<date>2008-09-20</date>
	<revremark>Complete draft.</revremark>
      </revision>
      <revision>
	<revnumber>0.1</revnumber>
	<date>2008-08-15</date>
	<revremark>First version.</revremark>
      </revision>
    </revhistory>
  </info> 
  
  <!--              -->
  <!-- Introduction -->
  <!--              -->
  <section xml:id="intro">
    <title>Disclaimer and Prerequisites</title>
    <para>
      This document has been devised as a practical hands-on
      introduction to the use of ForSyDe's implementation. Thus, it is
      intentionally informal and non-exhaustive. If you are interested
      in ForSyDe's theoretical foundations please refer to the <link
      xlink:href="http://www.ict.kth.se/forsyde/index.html#documentation">Documentation
      section</link> in our <link
      xlink:href="http://www.ict.kth.se/forsyde/">website</link>.
    </para>
    
    <para>
      In order to take full advantage of this tutorial, it is
      essential to have a good background in the <link
      xlink:href="http://www.haskell.org">Haskell</link> programming
      language. Familiarity with some Haskell extensions (<link
      xlink:href="http://www.haskell.org/th">Template Haskell</link>,
      <link
      xlink:href="http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies">Multiparameter
      Type Classes with Functional Dependencies</link>, <link
      xlink:href="http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls">Undecidable
      and Overlapping Instances</link>) might help but is not vital.
    </para>
  
  </section>
  
  <!--                    -->
  <!-- Installing ForSyDe -->
  <!--                    -->
  <section xml:id="install">
    <title>Installing ForSyDe</title>
    
    <para>
      ForSyDe is implemented as a Haskell-embedded Domain Specific
      Language (DSL). As intimidating as the previous phrase might
      sound, from a practical point of view it only means that, to all
      effects, ForSyDe is simply a Haskell library.
    </para>
    
    <para>
      As it was already stated in <xref linkend="intro"/>, ForSyDe
      relies on many Haskell extensions, some of which are exclusive
      to GHC. For that reason, a recent version of GHC is required to
      build ForSyDe<footnote><para>ForSyDe has been tested to run
      successfully on Linux, OSX-Leopard-x86 and Windows when compiled
      under GHC version 6.8.2. Due to the massive number of instances
      automatically generated in ForSyDe, it is not recommended to use
      a higher version of GHC until <link
      xlink:href="http://hackage.haskell.org/trac/ghc/ticket/2328">bug
      #2328</link> is fixed.</para></footnote>.
    </para>
    
    <para>
      ForSyDe's library is available on Haskell's <link
      xlink:href="http://hackage.haskell.org">HackageDB</link>, a
      popular repository of Haskell <link
      xlink:href="http://www.haskell.org/cabal">Cabal</link> packages.
      If ForSyDe is the first Cabal package you install or your memory
      needs to be refreshed in this matter, you should read <link
      xlink:href="http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package">"How
      to install a Cabal package"</link>.
    </para>
    
    <para>
      At the time being, ForSyDe depends on the <link
      xlink:href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level"><code>type-level</code></link>
      and <link
      xlink:href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parameterized-data"><code>parameterized-data</code></link>
      packages to offer numerically-parametrized vectors, and on some
      other packages normally distributed with GHC (e.g. <link
      xlink:href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl"><code>mtl</code></link>
      ..)
    </para>
    
  </section>
  
  <!--                         -->
  <!-- Introduction to ForSyDe -->
  <!--                         -->
  <section xml:id="introForSYDe">
    
    <title>Introduction to ForSyDe</title>
    
    <para>
      This section is a short introduction to some basic concepts
      surrounding ForSyDe which are vital to understand how to use its
      implementation.  If you cannot wait to get your hands dirty and begin
      with the implementation examples, go directly to <xref
      linkend="DEvsSE"/>.
    </para> 
    
    
    <para>
      ForSyDe, which stands for Formal System Design, is a
      methodology aimed at raising the abstraction level in which
      systems (e.g. System on Chip Systems, Hardware or Software) are designed.
    </para>
    
    <para>
      ForSyDe systems are modelled as networks of <emphasis>processes</emphasis>
      interconnected by <emphasis>signals</emphasis>. In
      addition, the designer is allowed to use processes belonging to
      different <emphasis>Models of Computation</emphasis>.
    </para>
    
    <para>
      In order to understand how systems are modelled, it is important to
      get familiar with the concepts outlined above.
    </para>
    
    <section>
      <title>Signals</title> 

      <para>
	Signals can be intuitively defined as
	streams of information which flow through the different
	processes forming a system.
      </para>

      <para>
	For example, this is a signal containing the first 10 positive numbers
      </para>
      <example><title>Signal containing the first 10 positive numbers</title>&lt;1,2,3,4,5,6,7,8,9,10&gt;</example>
      
      <para>
	More formally, a signal is a sequence of events where each
	event has a tag and a value. In ForSyDe, the tag of an event
	is implicitly given by the event's position on the list. For
	instance, the sample signal above is formed by integer values
	which are identical to the signal implicit tags.
      </para>
      
      <para>
	It is important to note that signals are homogeneous (i.e. a
	signal cannot carry values belonging to different types)
      </para>
      
 
      
      <note>The interpretation of tags, as we will see, is determined
      by the <emphasis>Model of Computation</emphasis> used, e.g. an
      identical tag of two events in different signals does not
      necessarily imply that these events happen at the same
      time. </note>
    </section>
    
    <section>
      <title>Processes</title>
      <para>
	Processes are pure functions on signals, i.e. for a given set of input signals a process always gets the same
	set of output signals.
      </para>
	
      <figure xml:id="processfun">
	<title>Processes viewed as functions</title>
	<mediaobject>
	  <alt>Process function definition.</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="4in" fileref="figures/processfun.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure>
      
      <para>
	They can also be viewed as a black box which performs computations over its input signals and
	forward the results to adjacent processes through output signals.
      </para>
      
      <figure xml:id="processbox">
	<title>Processes viewed as boxes</title>
	<mediaobject>
	  <alt>Process box</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="2.5in" fileref="figures/processbox.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure>      
      
      <para>
	Note that this still allows processes to have internal
	state. A process does not necessarily react identically the
	same event applied at different times. But it will produce the same, possibly infinite,  output signals
	when confronted with identical, possibly infinite, input signals.
      </para>
      
      <para>
	One of the simplest examples one can think of, is a process which merely adds one to every value in its
	only input signal: <emphasis>plus1</emphasis>.	
      </para>
      
      <example>
	<title>The <emphasis>plus1</emphasis> process</title>
	plus1(&lt;v<subscript>1</subscript>, v<subscript>2</subscript>, v<subscript>3</subscript>, ...&gt;) =
	&lt;v<subscript>1</subscript>+1, v<subscript>2</subscript>+1, v<subscript>3</subscript>+1, ...&gt;)
      </example>
    </section>
    
    
    <section>
      <title>Process Constructors</title>
      
      <para>
	In ForSyDe, all processes, even <emphasis>plus1</emphasis>, must be created from 
	<emphasis>process constructors</emphasis>. A process constructor takes zero or more
	functions and/or values which determine the initial state and behaviour of the process to be created.  
      </para>

      <figure xml:id="processcons">
	<title>A process constructor</title>
	<mediaobject>
	  <alt>process constructor box</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="3in" fileref="figures/processcons.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure>
      
      
      <para>
	The ForSyDe methodology offers a set of well-defined
	process constructors. For example, certain process constructors are aimed at creating
	synchronous systems. Synchronous systems are governed by a global clock and all processes consume and produce
	exactly one signal event in each clock-cycle.
      </para>
	
      <para>
	For instance, <emphasis>mapSY</emphasis>, (where the suffix
	<emphasis>SY</emphasis> stands for
	<emphasis>SY</emphasis>ncrhonous) is a
	combinational<footnote><para>The term combinational comes from
	Digital Circuit Theory. In the context of ForSyDe, a
	synchronous process is combinational, as opposed to
	sequential, if its outputs don't depend on the history of the
	input signals. That is, the process is stateless, all output
	values can only depend on the input values consumed in the
	same clock cycle.</para></footnote> process constructor.
	<emphasis>mapSY</emphasis> takes a function
	<emphasis>f</emphasis> and creates a process with one input
	and output signal, resulting from the application of
	<emphasis>f</emphasis> to every value in the input.
      </para>
	
      <figure xml:id="mapSY">
	<title>The synchronous, combinational map process constructor: <emphasis>mapSY</emphasis></title>
	<mediaobject>
	  <alt>mapSY</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="5.5in" fileref="figures/mapSY.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure>
      
      <para>
	<emphasis>plus1</emphasis> can, in fact, be defined in terms of
	<emphasis>mapSY</emphasis> as <emphasis>plus1 = mapSY
	(+1)</emphasis>.
      </para>
      
      <para>
	ForSyDe also supports synchronous, sequential
	systems. However, it does not allow loops formed exclusively
	by combinational processes, also known as
	<emphasis>combinational loops</emphasis>, <emphasis>zero-delay
	loops</emphasis> or <emphasis>feedback loops</emphasis>, since
	their behaviour is not always decidable. Even with that,
	combinational loops are still possible if they contain at
	least one process formed by the
	<emphasis>delaySY<subscript>k</subscript></emphasis>
	(<emphasis>k</emphasis> > 0) constructor, which is defined as follows.
      </para>
      
      
      <figure xml:id="delaySY">
	<title>The synchronous, sequential delay process constructor: <emphasis>delaySY</emphasis></title>
	<mediaobject>
	  <alt>delaySY</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="5.5in" fileref="figures/delaySY.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure>
      

      <para>
	<emphasis>delaySY<subscript>k</subscript></emphasis> takes an
	initial value <emphasis>s<subscript>0</subscript></emphasis>
	and creates a process which appends
	<emphasis>s<subscript>0</subscript></emphasis>, replicated
	<emphasis>k</emphasis> times, to its input
	signal. <emphasis>delaySY</emphasis> provides the basic
	mechanism with which to build sequential systems.
      </para>
      
      <para>
	Both <emphasis>mapSY</emphasis> and
	<emphasis>delaySY<subscript>k</subscript></emphasis> are
	considered primitive process constructors, since they cannot
	be defined in terms of simpler ones. Primitive constructors
	can be combined, forming derived process
	constructors. For instance, <emphasis>sourceSY</emphasis> is
	the result of combining
	<emphasis>delaySY<subscript>1</subscript></emphasis> (normally
	denoted simply as <emphasis>delaSY</emphasis>) and
	<emphasis>mapSY</emphasis>.
      </para>
      
      <figure xml:id="sourceSY">
	<title>The <emphasis>sourceSY</emphasis> derived process constructor</title>
	<mediaobject>
	  <alt>delaySY</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="5in" fileref="figures/sourceSY.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure> 
      
      <para>
	<emphasis>sourceSY</emphasis> takes an initial value <emphasis>s<subscript>0</subscript></emphasis>
	and a function <emphasis>f</emphasis>, and creates a sequential process with no
	inputs and just one output, resulting from the reiterated application of <emphasis>f</emphasis>
	to <emphasis>s<subscript>0</subscript></emphasis>.
      </para>

      <para>
	For example, <emphasis>sourceSY</emphasis>(1,(+1)), is a
	counter with <emphasis>1</emphasis> as its initial value.
      </para>

      <para>
	ForSyDe supplies many other process constructors (e.g. <code>zipWithSY</code>, <code>mealySY</code> ...). However, a thoroughly description
	is out of the scope of this tutorial. 
      </para>
      
    </section>
    <section>
      <title>Models of Computation and Domain Interfaces</title>
      
      <para>
	A <emphasis>Model of Computation</emphasis> (MoC), also known
	as <emphasis>Computational Model</emphasis>, establishes a set of
	constraints on the possible processes and signals contained by
	a system. A system is said to belong to certain
	<emphasis>MoC</emphasis> if it satisfies its
	constraints. 
      </para>
      
      <para>
	The behaviour of a process is observed in its
	<emphasis>evaluation</emphasis>. The evaluation is divided
	in atomic steps called <emphasis>evaluation
	cycles</emphasis>, during which the process produces and
	consumes signal values. MoCs specify how and when evaluation
	cycles are fired.
      </para>
      
      <para>
	ForSyDe currently offers 3 MoCs.
      </para>
    
      <itemizedlist>
	<listitem>
	  <para>
	    The <emphasis role="strong">Synchronous MoC</emphasis> was
	    already mentioned in previous section.  All systems
	    contain an implicit global clock. Its cycle matches
	    the evaluation cycle of all the system processes, during which
	    they must consume and produce exactly one value on every
	    input and output signal.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis role="strong">Untimed
	    MoC</emphasis>. Communication between processes can be
	    thought as a specific variant of asynchronous, blocking
	    message passing. There is no notion of time or global
	    clock.
	  </para>
	  <para>
	    Contrary to the Synchronous MoC, in which all the system
	    processes evaluate in parallel during every cycle,
	    untimed processes are fired individually. A process only
	    evaluates when all their inputs have a minimum number of
	    values ready to be read. That number may vary between
	    inputs, but is fixed for each of them. On the other hand,
	    the number of values produced by output signals 
	    may vary independently between evaluation cycles.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The <emphasis role="strong">Continuous MoC</emphasis>
	    models continuous signals representing them as
	    continuous one-variable, piecewise functions.
	  </para>    
	  <figure>
	    <title>Continuous signal</title>
	    &lt; (sin(x),[-10,0)), (-sin(x),[0,10)) &gt;
	    <mediaobject>
	      <alt>Piecewise function plot</alt>
	      <imageobject>
		<imagedata align="center" valign="middle" width="4in" fileref="figures/piecewise_sin.svg" format="SVG" />
	      </imageobject>
	    </mediaobject>    
	  </figure>
	    
	</listitem>
	
      </itemizedlist>
      
      <para>
	ForSyDe specifies a set of process constructors for each MoC. A
	ForSyDe system is thus guaranteed to belong to a MoC if it was
	built using constructors from one of those sets.
      </para>

      <para>
	Nevertheless, it is possible to build heterogeneous systems,
	i.e. systems which mix different MoCs. For that purpose,
	ForSyDe provides special<footnote><para>In the sense of
	belonging to any particular MoC</para></footnote> processes in
	charge of connecting two subsystems which belong to different
	MoCs or which have different timing specifications (e.g. two
	Synchronous subsystems with a different clock period).
      </para>
      
    </section>
  </section>
  
  <!--                                           -->
  <!-- Deep-embedded vs Shallow-embedded Signals -->
  <!--                                           -->
  <section xml:id="DEvsSE">
    <title>Deep-embedded vs Shallow-embedded signals</title>
    <para>
      As we already mentioned, ForSyDe is implemented as a
      Domain Specific Embedded Language (DSL) on top of Haskell.
      Actually, ForSyDe offers two different DSL flavours
      according to how signals are modelled.
    </para>


    <itemizedlist>
      <listitem>
	<para>
	  <emphasis role="strong">Shallow-embedded signals</emphasis>
	  (<link
	  xlink:href="http://hackage.haskell.org/packages/archive/ForSyDe/3.0/doc/html/ForSyDe-Shallow-Signal.htm"><code>ForSyDe.Shallow.Signal</code></link>)
	  are modelled as streams of data isomorphic to lists.
	</para>
	
	  <programlisting language="haskell">
data Signal a = NullS | a :- Signal a
	  </programlisting>
	  <para>
	    Systems built with them are unfortunately restricted to
	    simulation, however, shallow-embedded signals provide a
	    rapid-prototyping framework with which to experiment with
	    Models of Computation.
	  </para>
      </listitem>
      
      <listitem>
	<para>
	  <emphasis role="strong">Deep-embedded signals</emphasis>
	  (<link
	  xlink:href="http://hackage.haskell.org/packages/archive/ForSyDe/3.0/doc/html/ForSyDe-Signal.htm"><code>ForSyDe.Signal</code></link>)
	  are used in a similar way to shallow-embedded signals but
	  are modelled as an abstract data type which, transparently
	  to the end user, keeps track of the system
	  structure<footnote><para>Current implementation is based on
	  <link
	  xlink:href="http://www.cs.chalmers.se/~koen/Lava/">Lava</link>'s
	  <link
	  xlink:href="http://www.cs.chalmers.se/~koen/pubs/entry-asian99-lava.html">Observable
	  Sharing</link>.</para></footnote>. Based on that structural
	  information, ForSyDe's embedded compiler can perform
	  different analysis and transformations such as simulating
	  the system or translating it to other target languages
	  (e.g. VHDL and GraphML).
	</para>
	<para>
	  As a drawback, the deep-embedded API can only currently
	  build systems belonging to the Synchronous MoC and domain
	  interfaces are not yet supported. This limitation is,
	  however, likely to change in the future.
	</para>
      </listitem>
    </itemizedlist>
  </section>
  
  <!--                       -->
  <!-- Deep-embedded signals -->
  <!--                       -->
  <section xml:id="DE">
    <title>Using deep-embedded Signals</title>
    
    <para>
      In this section we go through a few simple sample systems
      built with ForSyDe's deep-embedded API. We will create both
      combinational and sequential systems all belonging to the
      Synchronous MoC (the only MoC currently supported by this API).
    </para>

    <section xml:id="combinational">
      <title>Combinational Systems</title> 
      <para>
	A system or process is combinational if its outputs are
	stateless, i.e. they don't depend on past system events.
      </para>
      <!--                                 -->
      <!-- A simple combinational system   -->
      <!--                                 -->
      <section xml:id="plus1">
	<title>A naive combinational system: <emphasis>plus1</emphasis></title>
	
	<para>
	  We are going to implement <emphasis>plus1</emphasis>, ForSyDe's <emphasis>Hello World</emphasis>, a
	  system with takes integer values, adds 1 to them and forwards the result
	  through its output signal.
	</para>
	
	<para>
	  As we mentioned previously, the <emphasis>plus1</emphasis>
	  process can be created in terms of the
	  <emphasis>mapSY</emphasis> process constructor.  Here is the
	  signature of <code>mapSY</code> in the deep-embedded API.
	</para>
	
	<programlisting language="haskell">
mapSY :: (ProcType a, ProcType b) =>
         ProcId -> ProcFun (a -> b) -> Signal a -> Signal b	
	</programlisting>
	
	<para>
	  <code>mapSY</code> works similarly to Haskell's
	  <code>map</code> function. It creates a process which applies a
	  function to every value in a signal. Let's have a closer look
	  at its arguments.
	</para>
	
	<variablelist>
	  <varlistentry>
	    <term><code>ProcId</code></term>
	    <listitem>
	      The process identifier, simply a textual tag which
	      univocally identifies the process created (<code>type ProcId
	      = String</code>).
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>ProcFun (a->b)</code></term>
	    <listitem>
	      <para>
		A process function. The function which will be applied to every element in the input signal. In the
		case of <code>plus1</code> we will need a function computationally equivalent to <code>(+1)</code>.
	      </para>
	      <para>
		Both <code>a</code> and <code>b</code> must be instances
		of <code>ProcType</code> (read Process Type).
		<code>ProcType</code> is used by ForSyDe's embedded
		compiler to extract type and structure information of expressions. <!-- Theoretically, any
		instance of <link
		xlink:href="http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Basics.html#t:Data"><code>Data</code></link>
		should suffice due to the overlapping instance
		<code>Data a => ProcType a</code>. -->
	      </para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>Signal a</code></term>
	    <listitem>
	      Input signal.
	    </listitem>
	  </varlistentry>
	  
	  
	  <varlistentry>
	    <term><code>Signal b</code></term>
	    <listitem>
	      Output signal.
	    </listitem>
	  </varlistentry>
	  
	</variablelist>
	
	
	Now, we are ready to start implementing <emphasis>plus1</emphasis>.
	
	<programlisting language="haskell">
{-# LANGUAGE TemplateHaskell #-}
module Plus1 where

import ForSyDe
import Data.Int (Int32)
	</programlisting>
	
	
	
	<para>
	  We need to import ForSyDe's library and
	  <code>Int32</code>. Since deep-embedded systems might be
	  later translated to hardware, it is required to be specific
	  about the size of integers used (the size of <code>Int</code> is
	  platform-specific).  Additionally, in all ForSyDe
	  deep-embedded designs we need to tell GHC to enable the <link
	  xlink:href="http://www.haskell.org/th/">Template
	  Haskell</link> (TH) extension, here is why:
	</para>
	
	<programlisting language="haskell">
-- A process function which adds one to its input
addOnef :: ProcFun (Int32 -> Int32)
addOnef = $(newProcFun [d|addOnef :: Int32 -> Int32 
                          addOnef n = n + 1     |])
	</programlisting>     
      
	<para>
	  In the code above, we declared the <code>ProcFun</code> needed
	  by <code>mapSY</code>. It simply takes an <code>Int32</code> value
	  and adds 1 to it.
	</para>
	
	<para>
	  Instead of creating a specific DSL to express computations
	  in the deep-embedded model, ForSyDe uses TH to allow using
	  plain Haskell. In principle, <code>ProcFun</code>s can make
	  use of any Haskell feature supported by TH. However, such
	  features might not be supported or make sense for certain
	  backends (e.g. lists and thus, list comprehensions, are
	  difficult to support in VHDL). Thus, in this tutorial we will
	  create systems which are compatible with every backend. For example,
	  writing <code>addOnef = (+1)</code> instead of <code>addOnef n = n +1</code>
	  is more compact, however the VHDL backend does not currently support
	  sections nor points-free notation.
	</para>
	
	<para>
	  In order to use ForSyDe it is not vital to understand what is
	  really happening, but, for those curious about it, here is how
	  the TH trick works. First, the <code>[d| .. |]</code> brackets
	  enclosing the function declaration lift its AST (Abstract
	  Syntax Tree). Then, the AST is used by <code>newProcFun</code>
	  to splice (expand in TH's terminology) a <code>ProcFun</code>.
	  It is important to note that everything happens at compile-time.
	</para>
	
	<para>
	  Here is the rest of the system definition.  
	</para>
	
	<programlisting language="haskell">
-- System function (simply a process in this case) which uses addOnef
plus1Proc :: Signal Int32 -> Signal Int32
plus1Proc = mapSY "plus1Proc" addOnef


-- System definition associated to the system function
plus1SysDef :: SysDef (Signal Int32 -> Signal Int32)
plus1SysDef = newSysDef plus1Proc "plus1" ["inSignal"] ["outSignal"]
	</programlisting>
      
	
	<para>
	  First, we use <code>mapSY</code> to create process. Then we create the final definition
	  of the <emphasis>plus1</emphasis> system with <code>newSysDef</code>. Here is its type signature.
	</para>
	
	<programlisting language="haskell">
newSysDef :: (SysFun f) => f -> SysId -> [PortId] -> [PortId] -> SysDef f
	</programlisting>
	
	<variablelist>
	  <varlistentry>
	    <term><code>f</code></term>
	    <listitem>
	      A <code>SysFun</code> (system function) describing the
	      system. It results from the combination of one or more
	      processes. ForSyDe uses a trick similar to <link
	      xlink:href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html"><code>Text.Printf</code></link>
	      in order to emulate variadic functions (different systems
	      are obviously allowed to have different number of inputs
	      and outputs).
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>SysId</code></term>
	    <listitem>
	      Textual tag identifying the system. <code>type SysId = String</code>.
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>[PortId]</code></term>
	    <listitem>
	      List of port identifiers for the system inputs and outputs. <code>type PortId = String</code>.
	    </listitem>
	  </varlistentry>
	  
	</variablelist>
	
	<para>
	  Now we can simulate our system, or, as we will see later on, translate it to VHDL or GraphML.
	</para>
	
	<programlisting language="haskell">
simulate :: SysFunToSimFun sysFun simFun => SysDef sysFun -> simFun
	</programlisting>
	
	
	<para>
	  <code>simulate</code> transforms our system definition into a
	  list-based function with the help of a multiparameter
	  typeclass, <code>SysFunToSimFun</code>, in charge of
	  implementing the <emphasis>type-level</emphasis> translation of the system
	  signals to lists.
	</para>
	
	<screen>
<prompt>$</prompt> ghci Plus1.hs
<prompt>*Plus1></prompt> let simPlus1 = simulate plus1SysDef 
<prompt>*Plus1></prompt> :t simPlus1
simPlus1 :: [Int32] -> [Int32]
<prompt>*Plus1></prompt> simPlus1 [1..10]
[2,3,4,5,6,7,8,9,10,11]
	</screen>      
	
	<para>
	  Simulation is lazy, allowing to work with infinite signals.
	</para>
	
	<screen>
<prompt>*Plus1></prompt> take 10 $ simPlus1 [1,1..] 
[2,2,2,2,2,2,2,2,2,2]
	</screen>
	
	<para>
	  It is important to remark that ForSyDe does not support
	  systems containing <emphasis>combinational loops</emphasis>.
	  If such a loop is found, an error will be reported.
	</para>
	
	<para>
	  For example, here is a system containing a combinational
	  loop, built with a mutually recursive call between two
	  processes adding one to their inputs.
	</para>

	<programlisting language="haskell">
combLoopSysDef :: SysDef (Signal Int32)
combLoopSysDef = newSysDef s "combLoop" [] ["out"] 
 where s  = mapSY "addOne1" addOnef s'
       s' = mapSY "addOne2" addOnef s
	</programlisting>
	
	<para>
	  As we mentioned, <code>combLoopSysDef</code> cannot be simulated.
	</para>

	<screen>
*Plus1> simulate combLoopSysDef 
*** Exception: detected combinational loop
	</screen>
	
      </section>
      <section>
	<title>Keypad encoder</title>

	<para>
	  Here is a slightly more complex example. We have a keypad with
	  4 arrow buttons connected to our synchronous system. The
	  key-presses are sent in the form of a 4-bit vector. Each bit
	  indicates whether the corresponding button is pressed (high
	  value) or not (low value) according to the diagram below.
	</para>
	
	
	<figure xml:id="encoderfig">
	  <title>Keypad encoder</title>
	  <mediaobject>
	    <alt>Keypad encoder diagram</alt>
	    <imageobject>
	      <imagedata align="center" valign="middle" width="2.5in" fileref="figures/encoder.svg" format="SVG" />
	    </imageobject>
	  </mediaobject>
	</figure>

	
	<para>
	  In order to work more comfortably and forget about multiple
	  key-strokes at once, we want to encode each key-press event
	  with a specific Haskell type: <code>data Direction = Left |
	  Down | Right | Up</code>.
	</para>
	
	<para>
	  Of course, keys are not necessarily pressed all the time.
	  Thus, instead of encoding the input vector into a signal of
	  <code>Direction</code> we will output signals of
	  <code>AbstExt Direction</code>.
	</para>

	
	  <programlisting language="haskell">
data AbstExt a = Abst | Prst a
	  </programlisting>

	
	<para>
	  <code>AbstExt</code> (read absent-extended) is ForSyDe's
	  equivalent to the popular Haskell type <code>Maybe</code>.
	  It is used to introduce absent values in signals, in our
	  particular case it will denote an absence of key presses.
	</para>

	
	Here is the definition of <code>Direction</code> together with
	the necessary imports for the definition of the whole system.

	
	<programlisting language="haskell">
{-# LANGUAGE TemplateHaskell, DeriveDataTypeable #-}
module Encoder where

import ForSyDe
import Language.Haskell.TH.Lift (deriveLift1)

import Prelude hiding (Left, Right)
import Data.Generics (Data,Typeable)
import Data.Param.FSVec
import Data.TypeLevel.Num hiding ((==))


data Direction = Left | Down | Right | Up
 deriving (Typeable, Data, Show)

$(deriveLift1 ''Direction)
	</programlisting>

	<para>
	  There are a few things worth remarking
	  <itemizedlist>
	    <listitem>
	      <para>
		Since we are defining new constructors named <code>Left</code> and <code>Right</code>, to avoid clashes
		with the identically-named constructors of <code>Either</code> we hide their import from
		the <code>Prelude</code>.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		We are defining a custom enumerated
		datatype<footnote><para>More formally, a datatype with
		data constructors whose arity is zero in all
		cases.</para></footnote> (<code>Direction</code>)
		whose values will be carried by system signals. All
		the values used in a system, and
		<code>Direction</code> in particular, must be
		instances of the private typeclass
		<code>ProcType</code>.
	      </para>
	      
	      <programlisting language="haskell">
class (Data a, Lift a) => ProcType a

-- Some existing (overlapping) instances of ProcType
instance (Data a, Lift a) => ProcType a
instance ProcType a =>  ProcType (AbstExt a)
instance (ProcType a, ProcType b) =>  ProcType (a,b)
...  
	      </programlisting>
		
	      <para>
		The <code>ProcType</code> constraint is required,
		among other reasons, to provide type and structural
		information of datatypes to ForSyDe's embedded
		compiler. The overlapping instances are needed to
		obtain datatype information regardless of 
		the nesting of values in other supported datastructures.
	      </para>
	      
	      <para>
		Due to the <code>(Data a, Lift a) => ProcType a</code>
		instance all we need to do in order to use our custom
		enumerated datatypes with ForSyDe is creating
		instances of <code>Data</code> (which implicitly
		requires an instantiation of <code>Typeable</code>)
		and Template Haskell's <code>Lift</code> class.
	      </para>
		
	      <para>
		Fortunately, thanks to a GHC extension it is possible
		to derive instances for <code>Typeable</code> and
		<code>Data</code> (hence the
		<code>DeriveDataTypeable</code> language
		pragma). Additionally, ForSyDe provides a Template
		Haskell module
		<code>Language.Haskell.TH.Lift</code><footnote><para>Based
		on the <link
		xlink:href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/th-lift"><code>th-lift</code></link>
		package</para></footnote> to automatically generate
		instances of <code>Lift</code>. In this case, since we
		needed to instantiate a single datatype, we used
		<code>deriveLift1</code>.
	      </para>
	    </listitem>
	    
	    <listitem>
	      <para>
		The rest of the imports (<code>Data.Param.FSVec</code>
		and <code>Data.TypeLevel.Num</code>) come from the
		<link
		xlink:href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parameterized-data"><code>parameterized-data</code></link>
		and
		<link
		xlink:href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level"><code>type-level</code></link>
		packages in order to support fixed-sized vectors.
	      </para>
	    </listitem>

	  </itemizedlist>

	</para>
	
	<para>
	  Here is the code of the process function, needed to encode the button presses:
	</para>

	<programlisting language="haskell">
encoderFun :: ProcFun (FSVec D4 Bit -> AbstExt Direction)
encoderFun = $(newProcFun 
  [d| encode :: FSVec D4 Bit -> AbstExt Direction
      encode v = if v ! d0 == H then Prst Left  else
                 if v ! d1 == H then Prst Down  else
                 if v ! d2 == H then Prst Right else
                 if v ! d3 == H then Prst Up else Abst  |])
	</programlisting>

	<para>
	  The code should be self-explanatory, it makes use of the
	  type <code>ForSyDe.Bit.Bit</code>, with data constructors
	  <code>L</code> (low) and <code>H</code> (high), and of
	  vectors of size 4 (hence the <code>D4</code> type
	  parameter).  In order to get a deeper insight on how
	  <code>FSVec</code>s work, check <xref linkend="FSVec"/>. It
	  is important to note that the system does not take
	  simultaneous key-strokes in account, choosing the direction
	  with higher precedence (i.e. situated in the outermost <code>if</code>
	  expression). Also, using pattern matching with multiple
	  function clauses instead of nested <code>if</code>
	  expressions would had been more clear. However, the VHDL
	  backend currently only supports one clause.
	</para>
	
	<para>
	  Here is the remaining code needed to build the rest of the system.
	</para>

	<programlisting language="haskell">
encoderProc :: Signal (FSVec D4 Bit) -> Signal (AbstExt Direction)
encoderProc = mapSY "encoder" encoderFun

encoderSysDef :: SysDef (Signal (FSVec D4 Bit) -> Signal (AbstExt Direction))
encoderSysDef = newSysDef encoderProc "KeypadEncoder" ["arrowBits"] ["direction"]	  
	</programlisting>

	<para>
	  Finally, we can evaluate some simulations.
	</para>

	<screen>
<prompt>$</prompt> ghci -XTemplateHaskell Encoder.hs
<prompt>*Encoder></prompt> let simEncoder = simulate encoderSysDef 
<prompt>*Encoder></prompt> :t simEncoder
simEncoder :: [FSVec D4 Bit] -> [AbstExt Direction]
<prompt>*Encoder></prompt> simEncoder [$(vectorTH [L,H,L,L]), $(vectorTH [L,L,L,L])]
[Down,_]
	</screen>      
	
	

      </section>
    </section>
    

    <section xml:id="sequential">
      <title>Sequential Systems</title>
      
      <para>
	Now we are going to have a look at a couple of sequential systems, whose outputs, contrary to combinational systems,
	can depend on the system history (i.e. can have a state).
      </para>
     
      <!--                              -->
      <!-- A naive sequential system   -->
      <!--                              -->
      <section xml:id="counter">
	<title>A naive sequential system: <emphasis>counter</emphasis></title>
	<para>
	  Our goal is to generate a signal whose values match its tags
	  or, more intuitively, a counter from 1 to infinity.
	</para>
	
	<para>
	  This is clearly a sequential system since its output signal
	  is not stateless, each output value depends on the previous
	  one.
	</para>
	
	<programlisting language="haskell">
{-# LANGUAGE TemplateHaskell #-}
module Counter where

import ForSyDe
import Data.Int (Int32)
import Plus1 (addOnef)

counterProc :: Signal Int32
counterProc = out'
  where out  = mapSY "addOneProc" addOnef out'
        out' = delaySY "delayOne" 1 out

counterSysDef :: SysDef (Signal Int32)
counterSysDef = newSysDef counterProc "counter" [] ["count"]
	  </programlisting>
	  
	  <para>
	    We reuse <code>addOnef</code> from previous examples. The counter is built by the mutually recursive calls of
	    <code>mapSY</code> and <code>delaySY</code> which should be interpreted as parallel equations.
	  </para>
	  
	  <para>
	    Again, we can lazily simulate the system.
	  </para>
	  
	  <screen>
<prompt>$</prompt> ghci Counter.hs
<prompt>*Counter></prompt> :t simulate counterSysDef 
simulate counterSysDef :: [Int32]
<prompt>*Plus1></prompt> simulate counterSysDef
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17
^C Interrupted
	  </screen>

	  <para>
	    Actually, the definition of <code>counterProc</code> can be
	    simplified by using <code>sourceSY</code>, getting the following
	    equivalent declaration.
	  </para>
	  
	  <programlisting language="haskell">
counterProc :: Signal Int32
counterProc = sourceSY "counterProc" addOnef 1
	  </programlisting>	  

	</section>

	<section>
	<title>Serial full adder</title>
	
	<para>
	  A serial full adder which adds two streams of bits is a,
	  still simple, but more elaborated example of a sequential
	  system. Our system will receive pairs of bits which will be
	  added together, taking the resulting carry of last cycle in
	  account.
	</para>
	
	<para>
	  We are going to implement it as a Mealy FSM (Finite State Machine) following the diagram below.
	</para>
	
	<figure xml:id="fullAdderfig">
	  <title>Full Adder: Mealy Machine</title>
	  <mediaobject>
	    <alt>Moore states graph</alt>
	    <imageobject>
	      <imagedata align="center" valign="middle" width="3.5in" fileref="figures/fullAdderMealy.svg" format="SVG" />
	    </imageobject>
	  </mediaobject>
	</figure>
	
	<para>
	  ForSyDe provides derived process constructors to implement FSMs, in this case we will be using
	  <code>mealySY</code>.
	</para>
	
	<programlisting language="haskell">
mealySY :: (ProcType c, ProcType b, ProcType a) =>
           ProcId
        -> ProcFun (a -> b -> a)
        -> ProcFun (a -> b -> c)
        -> a
        -> Signal b
        -> Signal c
	</programlisting>
	
	
		
	<variablelist>
	  <varlistentry>
	    <term><code>ProcId</code></term>
	    <listitem>
	      The process identifier, used in the same way as in the
	      rest of the process constructors
	      (e.g. <code>mapSY</code> and <code>delaySY</code>).
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>ProcFun (a- > b -> a)</code></term>
	    <listitem>
	      <para>
		A process function in charge of calculating next state
		based on current state and current input.
	      </para>
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>ProcFun (a -> b -> c)</code></term>
	    <listitem>
	      <para>
		A process function in charge of calculating current output
		based on current state and current input.
	      </para>
	      </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>a</code></term>
	    <listitem>
	      <para>
		Initial state.
	      </para>
	      </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>Signal b</code></term>
	    <listitem>
	      Input Signal.
	    </listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><code>Signal c</code></term>
	    <listitem>
	      Output Signal.
	    </listitem>
	  </varlistentry>
	  
	</variablelist>

	
	
	<para>
	  Here is the Haskell code, which should be straightforward to understand.
	</para>

	
	<programlisting language="haskell">
{-# LANGUAGE TemplateHaskell #-}
module FullAdder where

import ForSyDe

faNextState :: ProcFun (Bit -> (Bit,Bit) -> Bit)
faNextState = $(newProcFun
  [d| faNextState :: Bit -> (Bit,Bit) -> Bit
      faNextState st input =
         if st == L then
            case input of
              (H, H) -> H
              _ -> L
         else
            case input of
              (L,L) -> L
              _ -> H
     |])

faOut :: ProcFun (Bit -> (Bit,Bit) -> Bit)
faOut= $(newProcFun
  [d| faOut :: Bit -> (Bit,Bit) -> Bit
      faOut st input =
         if st == L then
            case input of
              (L, L) -> L
              (L, H) -> H
              (H, L) -> H
              (H, H) -> L
         else
            case input of
              (L, L) -> H
              (L, H) -> L
              (H, L) -> L
              (H, H) -> H
     |])


faProc :: Signal (Bit,Bit) -> Signal Bit
faProc = mealySY "addProc" faNextState faOut L

faSysDef :: SysDef (Signal (Bit,Bit) -> Signal Bit)
faSysDef = newSysDef faProc "fullAdder" ["op1", "op2"] ["res"]	  
	</programlisting>

	Here is a little test.

	<screen>
*FullAdder> let simfa = simulate faSysDef 
*FullAdder> simfa [(L,L),(L,H),(H,H),(L,L)]
[L,H,L,H]
*FullAdder> 	
	</screen>


	</section>
    </section>
    
      
    <!--                   -->
    <!-- Using Components  -->
    <!--                   -->
    <section xml:id="components">
      <title>Using components</title>
      <para>
	A desired characteristic of any system design language is
	the possibility of creating hierarchical models.
      </para>
      
      <para>
	In ForSyDe's deep-embedded DSL, hierarchical design is implemented through components, let's see
	an example.
      </para>
      
      
      <figure xml:id="seqaddfour">
	<title><emphasis>AddFour</emphasis> system</title>
	<mediaobject>
	  <alt>AddFour diagram.</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="6in" fileref="figures/SeqAddFour.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The system above which, admittedly, would not be of much use
	in the real world, adds 4 to its input in serial steps of 1.
      </para>
      
      <para>
	Instead of creating 4 different processes and connecting them
	together, we can reuse the design of <emphasis>plus1</emphasis>
	placing 4 identical components.
      </para>

      <para>
	ForSyDe provides a primitive to create components or instances
	of a system: <code>instantiate</code>.
      </para>
      
      <programlisting language="haskell">
instantiate :: (SysFun f) => ProcId -> SysDef f -> f
      </programlisting>
      
      <para>
	<code>instantiate</code> creates a component out of a system
	definition. A component can be considered a special process
	(hence the <code>ProcId</code> parameter) containing an
	instance of its parent system (the system from which it is
	created).
      </para>

      <para>
	Instances behave identically to their parents and can be combined with
	other system processes.
      </para>
      
      <para>
	For example, here we create and simulate an instance of <emphasis>plus1</emphasis>
      </para>

      <screen>
$ ghci Plus1.hs
*Plus1> :t plus1SysDef
plus1SysDef :: SysDef (Signal Int32 -> Signal Int32)
*Plus1> let plus1Comp1 = instantiate "plus1_1" plus1SysDef 
*Plus1> :t plus1Comp1
plus1SysDef :: Signal Int32 -> Signal Int32
*Plus1> let nestedPlus1 = newSysDef plus1Comp1 "nestedPlus1" ["in1"] ["out1"]
*Plus1> simulate nestedPlus1 $ [1,2,3,4]
[2,3,4,5]
      </screen>
      
      <para>
	And here is the definition of the <emphasis>AddFour</emphasis> system.
      </para>
      
      <programlisting language="haskell">
module AddFour where

import Plus1 (plus1SysDef)

import ForSyDe
import Data.Int (Int32)

addFourProc :: Signal Int32 -> Signal Int32
addFourProc = plus1Comp "plus1_1" .
              plus1Comp "plus1_2" .
              plus1Comp "plus1_3" .
              plus1Comp "plus1_4"
 where plus1Comp id = instantiate id plus1SysDef

addFourSysDef :: SysDef (Signal Int32 -> Signal Int32)
addFourSysDef = newSysDef addFourProc "addFour" ["in1"] ["out1"]
      </programlisting>

      <para>
	Components, just like any other process, are functions over
	signals. This allows using all the combinatorial power of
	Haskell. In this particular case we have just used function
	composition.
      </para>
      
      <para>
	Here is the general workflow of ForSyDe modelling, including
	the use of components.
      </para>

      
      <figure xml:id="cwf">
	<title>Component workflow</title>
	<mediaobject>
	  <alt>Component workflow diagram.</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="6in" fileref="figures/compflow.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure>

      <orderedlist>
	<listitem>
	  <para>
	    The designer describes computations using process functions (<code>ProcFun</code>s).
	  </para>
	</listitem>
	  
	<listitem>
	  <para>
	    Those process functions, possibly with other constants,
	    are passed to process constructors in order to build
	    processes which are combined together,
	    creating the main process function.
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    The system function is transformed into a system definition by <code>newSysDef</code>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The system definition can be
	    <itemizedlist>
	      <listitem>
		passed to ForSyDe's embedded compiler, capable of simulating or
		translating it to other target languages (VHDL or GraphML at the time being).
	      </listitem>
	      <listitem>
		used to create components, bringing us back to step 2.
	      </listitem>
	    </itemizedlist>
	  </para>
	</listitem>
	
      </orderedlist>
      
    </section>
    
    <!--                -->
    <!-- VHDL Backend   -->
    <!--                -->
    <section xml:id="VHDL">
      <title>VHDL Backend</title>
      <para>
	ForSyDe's embedded compiler is able to translate system definitions to VHDL. That is
	done through the <code>writeVHDL</code>* functions.
      </para>

      <programlisting language="haskell">
writeVHDL :: SysDef a -> IO ()
writeVHDLOps :: VHDLOps -> SysDef a -> IO ()
      </programlisting>
      
      
      <para>
	For example, this is how we would generate the VHDL definition
	of <emphasis>AddFour</emphasis> and write it to disk.
      </para>
      
      
      <screen>
$ ghci AddFour.hs
*AddFour> writeVHDL addFourSysDef 
*AddFour> :q
Leaving GHCi.
$ ls -R addFour
vhdl

addFour/vhdl:
addFour_lib work

addFour/vhdl/addFour_lib:
addFour_lib.vhd

addFour/vhdl/work:
addFour.vhd plus1.vhd
      </screen>

      <para>
	Here is a diagram of the filetree generated for <code>addFour</code>.
      </para>
      

      <figure xml:id="VHDLTree">
	<title>VHDL filetree of <code>addFour</code></title>
	<mediaobject>
	  <alt>File tree diagram.</alt>
	  <imageobject>
	    <imagedata align="center" valign="middle" width="3.5in" fileref="figures/VHDLTree.svg" format="SVG" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	<code>writeVHDL</code> generates a VHDL filetree pending from current
	working directory. Assuming <code>$SYSNAME</code> is the
	system's name (<code>addFour</code> in this particular case):
      </para>      

      <itemizedlist>
	<listitem>
	  <para>
	    The main VHDL entity and architecture is written in <code>$SYSNAME/vhdl/work/$SYSNAME.vhdl</code>.
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    The VHDL translation of other systems included through component instantiation is also written under
	    <code>$SYSNAME/vhdl/work/</code>. In  the case of the <code>addFour</code> system, the compiler also
	    generates the file <code>plus1.vhd</code>.
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    A global VHDL library, <code>forsyde_lib.vhd</code>, is
	    bundled with ForSyDe's distribution and contains the
	    translation of basic monomorphic Haskell types to VHDL. It
	    is installed under the <code>data</code> directory of
	    ForSyDe's Cabal package, whose location is
	    system-dependent.
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    Since VHDL lacks support for <emphasis>parametric
	    polymorphism</emphasis>, the translation of polymorphic
	    types and functions is done on a per-system basis
	    (i.e. each different possible monotype of a polymorphic
	    Haskell type triggers a different translation). Thus, the
	    result of that translation is put in
	    <code>$SYSNAME/vhdl/lib/$SYSNAME_lib.vhd</code> and not
	    <code>forsyde_lib.vhd</code>.
	  </para>
	</listitem>
      </itemizedlist>	  

      <para>
	It is important to remember that, even if ForSyDe signals are polymorphic and
	<code>ProcFun</code>s can include any Haskell function definition, 
	some backends might be limited. In the case of the VHDL backend:
      </para>
      
      <itemizedlist>
	<listitem>
	  <para>
	    Accepted <code>Signal</code> types. <code>Signal a</code> is a valid
	    signal for the VHDL backend if <code>a</code> belongs to:
	  </para>
	  <orderedlist>
	    <listitem>
	      <para>
		Primitive types: <code>Data.Int</code>{<code>8</code>, <code>16</code>, <code>32</code>}, <code>Bool</code>,
		<code>ForSyDe.Bit</code>.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Custom types: enumerated<footnote><para>Again,
		consider an enumerated type to be an algebraic type
		whose data constructors all have arity
		zero.</para></footnote> types.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		The following containers, which can hold any primitive
		or custom type and can be unrestrictively nested:
		<code>Data.Param.FSVec</code>, tuples of unlimited
		size<footnote><para>In practice, the upper limit is
		Haskell-compiler dependent. In the case of GHC,
		current limit is 62.</para></footnote>,
	      </para>
	    </listitem>
	  </orderedlist>
	    
	</listitem>
	<listitem>
	  <para>
	    Although this will hopefully change in the future, the
	    declarations contained by <code>ProcFun</code>s must
	    be fairly simple. For instance:
	  </para>
	  <orderedlist>
	    <listitem>
	      <para>
		Points-free notation is not admitted.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		They can only contain a clause, multiple clauses are not accepted.
	      </para>
	    </listitem>
	  </orderedlist>
	</listitem>
      </itemizedlist>
      
      <para>
	Getting back to the function interface of the VHDL backend, it
	is possible to provide certain compilation options, namely to
	integrate Altera's <emphasis>Quartus II</emphasis> and
	<emphasis>Modelsim</emphasis> in our workflow. For that
	purpose we will use <code>writeVHDLOps</code>.
      </para>
      
      <para>
	For example, we can generate a <code>Quartus II</code> project
	and compile the generated VHDL code setting certain configuration
	options such as the pin-mapping and the FGPA model to be used.
      </para>
      


      <programlisting language="haskell">
compileQuartus :: IO ()
compileQuartus = writeVHDLOps vhdlOps addFourSysDef
 where vhdlOps = defaultVHDLOps{execQuartus=Just quartusOps}
       quartusOps = QuartusOps{action=FullCompilation,
                               fMax=Just 50, -- in MHz
                               fpgaFamiliyDevice=Just ("CycloneII",
                                                       Just "EP2C35F672C6"),
                               -- Three sample pin assignments
                               pinAssigs=[("in1[0]", "PIN_W1"),
                                          ("in1[1]", "PIN_W2"),
                                          ("in1[2]", "PIN_W3")]}
      </programlisting>

      <para>
	The code above generates the VHDL code for the
	<code>addFour</code> system, subsequently creating a Quartus
	project and running a full compilation of the project. We set
	a minimum acceptable clock frequency of 50 MHz, the FPGA
	family (<code>CycloneII</code>), specific device
	(<code>EP2C35F672C6</code>) and some pin assignments, which,
	for briefness' sake are not sufficient.
      </para>
      

      <para>
	It is important to note that, when needed, Quartus will
	split input and output port identifiers into several logical
	names corresponding to individual bits (e.g in1[0]).  Thus, it
	might be necessary to open Quartus in order to find out what
	logical names to use in pin assignments.
      </para>
      
      <para>
	In addition to <emphasis>Quartus II</emphasis>, the VHDL
	backend is able to interface with
	<emphasis>ModelSim</emphasis>.  For example, the following
	function shows how can we automatically compile the generated
	VHDL code with ModelSim.
      </para>
      
      
      <programlisting language="haskell">
compileModelSim :: IO ()
compileModelSim = writeVHDLOps vhdlOps addFourSysDef
 where vhdlOps = defaultVHDLOps{compileModelsim=True}
      </programlisting>

      <para>
	It is also possible to run test benches in ModelSim.
      </para>

      <programlisting language="haskell">
writeAndModelsimVHDL :: (SysFunToIOSimFun sysF simF) =>
                        Maybe Int -> SysDef sysF -> simF
writeAndModelsimVHDLOps :: (SysFunToIOSimFun sysF simF) =>
                           VHDLOps -> Maybe Int -> SysDef sysF -> simF
      </programlisting>
      
      Here are two examples:
      
      <screen>
$ ghci AddFour.hs
*AddFour> let vhdlSim = writeAndModelsimVHDL Nothing addFourSysDef 
*AddFour> :t vhdlSim
vhdlSim :: [Int32] -> IO [Int32]
*AddFour> vhdlSim [1..10]
[4,5,6,7,8,9,10,11,12,13,14]
      </screen>
      
      <para>
      In the example above, we simulate <code>addFour</code> without supplying a limit in the number of cycles to
      simulate. <code>writeAndModelsimVHDL</code> is strict, so, without a limit it will only work
      with finite input stimuli.
      </para>

      <screen>
$ ghci Counter.hs
*Counter> writeAndModelsimVHDL (Just 20) counterSysDef
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] 
      </screen>
      
      <para>
	In this case the system does not have any inputs and thus the simulation implicitly results in infinite
	output stimuli. Thus, it is necessary to set a limit in the number of cycles to simulate.
      </para>
      
      <para>
	In a general way, the <code>writeAndModelsimVHDL</code>* functions, generate a
	simulation function which will
      </para>

	<orderedlist>
	  <listitem>
	    <para>
	      Generate a VHDL model (implicitly using the
	      <code>writeVHDL</code>* functions).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Compile the resulting model with ModelSim. 
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Marshal the provided input stimuli from Haskell to VHDL
	      and generate a testbench in
	      <code>$SYSNAME/vhdl/test/$SYSNAME_tb.vhd</code>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Simulate the testbench with ModelSim and unmarshal the
	      results back to Haskell.
	    </para>
	  </listitem>
	</orderedlist>
	
	<para>
	  <code>writeAndModelsimVHDL</code>* give equivalent results to <code>simulate</code>, with a few caveats.
	</para>
	
	<itemizedlist>
	  <listitem>
	    <para>
	      <code>writeAndModelsimVHDL</code>*, unlike
	      <code>simulate</code>, are strict, and thus do not
	      support infinite stimuli. For that reason, it is
	      possible to set the number of cycles to simulate
	      (<code>Maybe Int</code> parameter).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <code>writeAndModelsimVHDL</code>* , provide <code>IO</code> simulation functions
	      whereas <code>simulate</code> is pure.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <code>writeAndModelsimVHDL</code>*  suffer all the limitations of the VHDL backend whereas
	      <code>simulate</code> can cope with any system.
	    </para>
	  </listitem>
	</itemizedlist>
	
    </section>
    
    
    <!--                   -->
    <!-- GraphML Backend -->
    <!--                   -->
    <section xml:id="GraphML">
      <title>GraphML Backend</title>
      <para>
	It is possible to use ForSyDe's GraphML backend in order to 
      </para>
      <orderedlist>
	<listitem>
	  <para>
	    Generate an XML-based intermediate representation of
	    a system for further processing.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Obtain system diagrams.
	  </para>
	</listitem>
      </orderedlist>
      
      <para>
	ForSyDe provides the following functions, similar to the ones of the VHDL backend. 
      </para>

      <programlisting language="haskell">
writeGraphML :: SysDef a -> IO ()
writeGraphMLOps :: GraphMLOps -> SysDef a -> IO ()
      </programlisting>
      
      <para>
	For example, here is how we would generate the GraphML translation of <code>addFour</code>
      </para>

      <screen>
$ ghci AddFour.hs
*AddFour> writeGraphML addFourSysDef 
*AddFour> :q
Leaving GHCi.
$ ls -R addFour
graphml

addFour/graphml:
addFour.graphml plus1.graphml
      </screen>
      
      <para>
	As we can see, a <code>.graphml</code> file is generated for each
	system involved. In this case, one for the main system
	(<code>addFour.graphml</code>) and another one for <code>plus1</code>
	which was instantiated by <code>addFour</code>.
      </para>

      <para>
	In order to embed ForSyDe metainformation, the GraphML backend
	makes use of the following <link
	xlink:href="http://graphml.graphdrawing.org/primer/graphml-primer.html#Attributes">GraphML-Attributes</link>:
      </para>
      
      <screen>
&lt;key id="process_type" for="node" attr.name="process_type" attr.type="string"/&gt;
&lt;key id="value_arg" for="node" attr.name="value_arg" attr.type="string"/&gt;
&lt;key id="procfun_arg" for="node" attr.name="procfun_arg" attr.type="string"/&gt;
&lt;key id="instance_parent" for="node" attr.name="instance_parent" attr.type="string"/&gt;
      </screen>

      <para>
	The keys above are used to tag nodes in different ways.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis role="strong"><code>process_type</code></emphasis> indicates what process constructor was used
	    to create a process node or if the node is an input or output port. 
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis role="strong"><code>value_arg</code></emphasis> contains a value passed to a process
	    constructor.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis role="strong"><code>procfun_arg</code></emphasis> contains a value passed to a process
	    constructor.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis role="strong"><code>instance_parent</code></emphasis> is specific to component nodes
	    and indicates the name of the parent system from which the component was instanciated.
	  </para>
	</listitem>
      </itemizedlist>
	
      <section>
	<title>Obtaining diagrams of ForSyDe</title>
	
	<para>
	  The GraphML definition does not provide a way to specify the
	  graphical representation of graphs (e.g. edge and node
	  shapes, colours, textual tags ...)
	</para>
	
	<para>
	  For that reason, <link
	  xlink:href="http://www.yworks.com"><emphasis>yWorks</emphasis></link>, a company
	  offering graph visualization products, created yFiles-GraphML, an extension to the GraphML
	  schema which adds graphical information. 
	</para>
	
	<para>
	  yWorks also distributes <link
	  xlink:href="http://www.yworks.com/en/products_yed_about.html"><emphasis>yEd</emphasis></link>,
	  a free (as in beer) multiplatform graph editor with
	  impressive automatic layout features.
	</para>

	<para>
	  Here is an example on how to generate and edit
	  yFiles-GraphML diagrams from ForSyDe systems. For this
	  purpose, we will use our <emphasis>counter</emphasis> system.
	</para>
	
	<screen>
$ ghci Counter.hs
*Counter> writeGraphMLOps defaultGraphMLOps{yFilesMarkup=True} counterSysDef 
*Counter> :q
$ ls -R counter
graphml

counter/graphml:
counter.graphml              sourceSY_counterProc.graphml
	</screen>
	
	
	
	<para>
	  <code>sourceSY_counterProc.graphml</code> contains the <emphasis>sourceSY</emphasis> process
	  used in the counter. Let's view its representation with yEd.
	</para>
	
	<para>
	  This is the unorganized representation we get right after opening <code>sourceSY_counterProc.graphml</code>
	  with yEd.
	</para>
      
	<figure xml:id="sourceSY_counterProc1">
	  <title>Initial yEd representation</title>
	  <mediaobject>
	    <alt>yEd diagram.</alt>
	    <imageobject>
	      <imagedata align="center" valign="middle" width="2.5in" fileref="figures/sourceSY_counterProc1.svg" format="SVG" />
	    </imageobject>
	  </mediaobject>
	</figure>
	
	<para>
	  All nodes are overlapped because the GraphML-yFiles backend
	  does not perform any kind of node placement nor edge
	  routing. yEd, however, does a very good job in this regard.
	</para>
	
	<para>
	  Before running a layout algorithm it is convenient to set
	  port constraints on the graph nodes. This is a workaround to
	  make yEd faithfully represent shared signals
	  (signals coming from the same process output), otherwise yEd
	  will treat them as different outputs. The GraphML format
	  (and GraphML-yFiles) allows edge sharing through the use of
	  <link xlink:href=""><emphasis>ports</emphasis></link>,
	  however, yEd does not currently respect them. Our current
	  solution is to set a location for the edge ends in the
	  GraphML backend and lock that location through yEd port
	  constraints.
	</para>
	
	<para>
	  In order to set the port constraints we will go to
	  <emphasis>Tools -> Constraints -> Port
	  Constraints</emphasis>.
	</para>
	
	<para>
	  The port constraints menu will initially look like this.
	</para>
	
	
	<figure xml:id="portConstraints1">
	  <title>Port constraints default options</title>
	  <mediaobject>
	    <alt>Port constraints menu</alt>
	    <imageobject>
	      <imagedata align="center" valign="middle" width="4in" fileref="figures/portConstraints1.png" format="PNG" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  These are the options we need to set in order to fix all
	  ports. Remember to click on OK after setting them.
	</para>
	
	<figure xml:id="portConstraints2">
	  <title>Desired port constraint options</title>
	  <mediaobject>
	    <alt>Port constraints menu</alt>
	    <imageobject>
	      <imagedata align="center" valign="middle" width="4in" fileref="figures/portConstraints2.png" format="PNG" />
	    </imageobject>
	  </mediaobject>
	</figure>
	
	<para>
	  It is important to note that due to a bug in yFiles format
	  it is not possible to save port constraints in <code>.graphml</code> files. Thus,
	  we will need to reset the port constraints every time a file is reopened.
	</para>

	<para>
	  Now we are ready to run an automatic layout algorithm. The
	  generated GraphML-yFiles graph is prepared to be displayed
	  from left to right. The hierarchical layout
	  (<emphasis>Layout -> Hierarchical -> Classic</emphasis>)
	  seems to give the best results for system diagrams. It is
	  important to set the Orientation to <emphasis>Left to
	  Right</emphasis> and allow <emphasis>Backloop Routing</emphasis>.
	</para>

	
	<figure xml:id="layout">
	  <title>hierarchical layout</title>
	  <mediaobject>
	    <alt>Hierarchical layout menu</alt>
	    <imageobject>
	      <imagedata align="center" valign="middle" width="4in" fileref="figures/layout.png" format="PNG" />
	    </imageobject>
	  </mediaobject>
	</figure>
	
	After clicking on <emphasis>OK</emphasis>, the system diagram should look like this:

	<figure xml:id="sourceSY_counterProc2">
	  <title>Final yEd representation</title>
	  <mediaobject>
	    <alt>yEd diagram.</alt>
	    <imageobject>
	      <imagedata align="center" valign="middle" width="5in" fileref="figures/sourceSY_counterProc2.svg" format="SVG" />
	    </imageobject>
	  </mediaobject>
	</figure>
	

	
      </section>
      <section>
	<title>GraphML limitations</title>
	<para>
	  Unfortunately, GraphML nor yFiles-GraphML + yEd suit all ForSyDe needs: 
	</para>
	
	<itemizedlist>
	  <listitem>
	    <para>
	      yFiles does not respect GraphML ports (source signal
	      sharing). We provide a workaround based on precalculate
	      the location of edge ends plus yEd routing port constraints
	      (which unfortunately cannot be saved).
	    </para>
	  </listitem>
	  
	  <listitem>
	    <para>
	      yEd wipes out external <code>&lt;data&gt;</code> tags
	      (external GraphML attributes). That includes ForSyDe's
	      metainformation, which will be lost after editing the
	      graph with yEd.
	    </para>
	  </listitem>
	  
	  <listitem>
	    <para>
	      GraphML nor yFiles-GraphML explicitly support subgraphs
	      but not subgraph sharing (components). Our solution is
	      to use external &lt;data&gt; tags indicating parent
	      systems in instance nodes. However, yEd is obviously
	      unaware of that trick, not being able to offer
	      hierarchical browsing.
	    </para>
	  </listitem>
	</itemizedlist>
	
      </section>
      
      
    </section>
    
    
  </section> <!-- Deep-embedded signals -->
  
  <!--                          -->
  <!-- Shallow-embedded signals -->
  <!--                          -->
  <section xml:id="SE">
    <title>Shallow-embedded signals</title>
    <para>
      As it was previously mentioned, ForSyDe offers a flavour of
      signals called shallow-embedded signals, modelled as
      streams of data:
    </para>

 	
    <programlisting language="haskell">
data Signal a = NullS | a :- Signal a
    </programlisting>

    <para>
      This representation offers some advantages:
    </para>
    
    <itemizedlist>
      <listitem>
	<para>
	  Rapid prototyping of systems.
	</para>
      </listitem>
      <listitem>
	<para>
	  It is easy to include new MoCs.
	</para>
      </listitem>
      <listitem>
	<para>
	  It supports all the MoCs covered by ForSyDe (Synchronous, Untimed and Continuous). 
	</para>
      </listitem>
    </itemizedlist>

    <para>
      Shallow-embedded signals also present some disadvantages:
    </para>
    
    <itemizedlist>
      <listitem>
	<para>
	  Systems built with them can only be
	  simulated. Shallow-embedded signals don't contain any
	  structural information. Thus, the models resulting from them
	  cannot be analyzed or compiled to other target languages.
	</para>
      </listitem>
      <listitem>
	<para>
	  No support for components. However, they are not really needed, components are not
	  useful for simulation and reusability can be achieved by function refactoring.
	</para>
      </listitem>
    </itemizedlist>
    
    <para>
      Here is the implementation of <emphasis>plus1</emphasis> using shallow-embedded signals. 
    </para>
    
    	
    <programlisting language="haskell">
module Plus1Shallow where

import ForSyDe.Shallow

import Data.Int(Int32)

plus1 :: Signal Int32 -> Signal Int32
plus1 = mapSY (+1)
    </programlisting>
	  
    <para>
      The system can be simulated directly simply by calling <emphasis>plus1</emphasis>.
    </para>

    <screen>
$ ghci Plus1Shallow.hs
*Plus1Shallow> :t signal
signal :: [a] -> Signal a
*Plus1Shallow> plus1 (signal [1..10])
{2,3,4,5,6,7,8,9,10,11}
    </screen>
    
    <para>
      We can also integrate deep-embedded models into shallow-embedded
      ones by using <code>simulate</code>, <code>signal</code> and
      <code>fromSignal</code> (the inverse of <code>signal</code>).
      In the example below, we use the deep-embedded
      <code>addFour</code> system and the shallow-embedded
      <code>plus1</code> to build <emphasis>plus5</emphasis>
    </para>
    
    <programlisting language="haskell">
module Plus5 where

import Plus1Shallow
import AddFour

import ForSyDe (simulate)
import ForSyDe.Shallow

import Data.Int (Int32)

plus5 :: Signal Int32 -> Signal Int32
plus5 = plus1 . signal . simulate addFourSysDef . fromSignal
    </programlisting>
    
    <screen>
$ ghci Plus5.hs      
*Plus5> plus5 (signal [1..10])
{6,7,8,9,10,11,12,13,14,15}
    </screen>

  </section>
  
  
  <!--        -->
  <!-- FSVec  -->
  <!--        -->
  <appendix xml:id="FSVec">
    <title><literal>FSVec</literal>s: Vectors parameterized in size</title>
    <section>
      <title>Goal</title>
      
      <para>
      We would like to numerically parameterize vectors using their
      length in order to implement fixed-sized vectors
      (<code>FSVec</code>).  Ideally, we would like to be able to
      implement something similar to this:
      </para>
      
      
      <programlisting>
v :: FSVec 23 Int -- Not Haskell	
      </programlisting>
      
      <para>
	<code>v</code> would be a a vector containing 23 <code>Int</code>s. Note it
	is not possible to directly do this in Haskell.
      </para>
      
      <para>
      The vector concatenation function would be something along the lines of:
      </para>
      
      <programlisting>
(++) :: FSVec s1 a -> FSVec s2 a -> FSVec (s1+s2) a -- Again, not valid Haskell
      </programlisting>
      
      <para>
	We would also like to establish static security constraints on
	functions. Those constrains would be checked at compile time
	guaranteeing a correct behaviour during runtime. For instance.
      </para>
      
      <programlisting>
head :: FSVec  (s > 0) a -> FSVec (s - 1) a -- Not Haskell
      </programlisting>

      <para>
	However, Haskell does not support dependent types (a numerically
	parameterized-vector is in practice a dependent type) nor type-level
	lambdas directly. Yet, it is still possible to implement our <code>FSVec</code>
	type using Haskell plus a few GHC extensions.
      </para>
      
    </section>
    <section>
      <title>How?</title>
      
      <para>
	Before diving into the details, let me spoil the final result:
      </para>

      
      <programlisting>
v :: FSVec D23 Int

(++) :: (Nat s1, Nat s2, Add s1 s2 s3) => FSVec s1 a -> FSVec s2 a -> FSVec s3 a

head :: Pos s => FSVec s a -> a
      </programlisting>
      
      <para>
	The code is a bit more verbose that the pseudo-Haskell code of
	previous section, but note that <emphasis role="strong">it
	is</emphasis> Haskell code (using the Multiparameter class
	extension).
      </para>


      <para>
	The trick is to emulate the parameters using type-level decimal
	numerals. But, What is that?
      </para>
      
    </section>
    
    <section>
      <title>Type-level decimal numerals</title>
      
      <para>
	We already mentioned that the trick is to use types to represent the size of
	the vector. So, we want a type parameter to represent a number, but, How?
      </para>
      
      <programlisting language="haskell">
-- Numerical digits
data D0 -- empty type (supported by a EmptyDataDecls GHC extension, 
        --             we could have included a phony constructor otherwise)
data D1
data D2
..
data D9

data a :* b -- connective to build multidigit numerals (empty again)
            -- note that the type constructor is infix (GHC TypeOperators extension)
      </programlisting>

      <para>
	Using the definitions above we can represent arbitrarily-sized natural
	numbers. Some examples:
      </para>

      <segmentedlist>
	<?dbhtml list-presentation="table"?>
	<segtitle>Number</segtitle>
	<segtitle>Type-level representation</segtitle>
	<seglistitem><seg>0</seg><seg><code>D0</code></seg></seglistitem>
	<seglistitem><seg>13</seg><seg><code>D1 :* D3</code></seg></seglistitem>
	<seglistitem><seg>1024</seg><seg><code>D1 :* D0 :* D2 :* D4</code></seg></seglistitem>
      </segmentedlist>

      <para>
	It seems sensible, but very verbose. It would certainly be nicer to be
	able to express 0 as <code>D0</code>, 13 as <code>D13</code> and so on.
      </para>
      
      <para>
	We solved the problem by using Template Haskell to generate
	type synonyms (aliases) up to <code>D5000</code>. The same
	trick was used to emulate binaries (up to
	<code>B10000000000</code>), octals (up to <code>O10000</code>)
	and hexadecimals (up to <code>H1000</code>):
      </para>
      
	<screen>
$ ghci -XTypeOperators  -XFlexibleContexts # Extensions used in different parts of this appendix
Prelude> :m +Data.TypeLevel
Prelude Data.TypeLevel> :i D124
type D124 = (D1 :* D2) :* D4
       -- Defined in Data.TypeLevel.Num.Aliases
Prelude Data.TypeLevel> :i HFF
type HFF = (D2 :* D5) :* D5
       -- Defined in Data.TypeLevel.Num.Aliases
Prelude Data.TypeLevel> :i B101
type B101 = D5  -- Defined in Data.TypeLevel.Num.Aliases
	</screen>      

	<para>
	  Of course, if you want to use a numeral which is out of the
	  aliases range, the only option is to use the verbose decimal
	  representation (it shouldn't be the normal case though)
	</para>
	
	<para>
	  Similarly to <code>D13</code>, <code>D124</code> ...
	  undercase value-level aliases (<code>d12</code>,
	  <code>d123</code>, .. declared as <code>undefined</code>)
	  are generated in order to create type-level values.
	</para>
	
	<screen>
Prelude Data.TypeLevel> :i d123
d123 :: (D1 :* D2) :* D3        -- Defined in Data.TypeLevel.Num.Aliases
	</screen>

	
	<para>
	  Fair enough. However, you might already have guessed that
	  <code>:*</code> can be used to construct ambiguous or
	  not-normalized numerals, for instance:
	</para>
	
	<programlisting language="haskell">
D0 :* D0 :* D1 -- numeral with trailing zeros
(D1 :* D0) :* (D2 :* D2) -- malformed numeral
	</programlisting>

	<para>	
	  Now is when the natural (<code>Nat</code>) and positive
	  (<code>Pos</code>) type-classes get in the game. We are
	  going to omit the instances but, trust us, they guarantee
	  that numerals are well-formed:
	</para>

	<programlisting language="haskell">
class Nat n where
 toNum :: Num a => n -> a

class Nat n => Pos n
	</programlisting>	
	
	<para>
	  <code>toNum</code> allows to pass the type-level numeral to value-level.
	</para>

	<screen> 
Prelude Data.TypeLevel> toNum d123
123
-- a non-normalized numeral
Prelude Data.TypeLevel> toNum (undefined :: D0 :* D1)
&lt;interactive&gt;:1:0:
   No instance for (Data.TypeLevel.Num.Sets.PosI D0)
     arising from a use of `toNum' at &lt;interactive&gt;:1:0-28
   Possible fix:
     add an instance declaration for (Data.TypeLevel.Num.Sets.PosI D0)
   In the expression: toNum (undefined :: D0 :* D1)
   In the definition of `it': it = toNum (undefined :: D0 :* D1)	  
	</screen>
	
	<para>
	  Based on the numerical representation we created, and using
	  multiparameter type-classes, we can define type-level
	  operations. The operations supported right now are:
	</para>
	
	<itemizedlist>
	  <listitem>
	    <para>
	      Arithmetic: Successor, Predecesor, Addition,
	      Subtraction, Multiplication, Division, Modulus, Greatest
	      Common Divisor, Exponentiation and Logarithm.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Comparison: trichotomy classification, (&lt;), (&gt;) (&lt;=),
	      (&gt;=), (==), Minimum and Maximum.
	    </para>
	  </listitem>
	</itemizedlist>
	
	<para>
	  Some examples:
	</para>
	
	<screen>
Prelude Data.TypeLevel> :i Data.TypeLevel.divMod
Data.TypeLevel.divMod :: (DivMod x y q r) => x -> y -> (q, r)
       -- Defined in Data.TypeLevel.Num.Ops
Prelude Data.TypeLevel> d23 `Data.TypeLevel.divMod` d2
(11,1)
	</screen>
	
	<para>
	  Note that the resulting type is calculated at compile time:
	</para>
	
	<screen>
Prelude Data.TypeLevel> :t d23 `Data.TypeLevel.divMod` d2
d23 `Data.TypeLevel.divMod` d2 :: (D1 :* D1, D1)
d23 `Data.TypeLevel.divMod` d2 :: (D1 :* D1, D1)
	</screen>
	
	<para>
	  Note as well that the operations are consistent, we cannot, for
	  instance, calculate the predecessor of zero:
	</para>

      <screen>
Prelude Data.TypeLevel> Data.TypeLevel.pred d0

&lt;interactive&gt;:1:0:
   No instances for (Data.TypeLevel.Num.Ops.Failure
                       (Data.TypeLevel.Num.Ops.PredecessorOfZeroError x),
[..]
	</screen>

	<para>
	  We can even add constraints to our own functions. For instance, we
	  want to guarantee (at compilation time) that a type-level
	  numeral number is lower than 6 and greater than 3.
	</para>
	
	<screen>
Prelude Data.TypeLevel> let check :: (Nat x, x :&lt;: D6, x :;&gt;: D3, Num a) => x -> a; check n = toNum n
	</screen>
	
	<para>
	  For example, 2 does not meet the constraints.
	</para>
	
         <screen>
Prelude Data.TypeLevel> check d2
&lt;interactive&gt;:1:0:
   Couldn't match expected type `CGT' against inferred type `CLT'
[..]
	 </screen>
	 
	 <para>
	   Whereas 4 does
	 </para>

	 <screen>
Prelude Data.TypeLevel> check d4
4
	 </screen>

	
      </section>
      
      <section>
	<title>Fixed Sized Vectors themselves</title>

	<para>
	  Getting back to fixed-sized vectors themselves, FSVec offers
	  a <link
	  xlink:href="http://hackage.haskell.org/packages/archive/parameterized-data/0.1.2/doc/html/Data-Param-FSVec.html">reasonably
	  rich vector API</link> based on type-level numerals.
	</para>
	
	<para>
	  For example, we can safely access the elements of a vector
	  without the risk of getting
	  <emphasis>out-of-bounds</emphasis> errors. 
	</para>
	
	<programlisting language="haskell">
(!) :: (Pos s, Nat i, i :&lt;: s) => FSVec s a -> i -> a
	</programlisting>


	<para>
	  The best part of it is that the bound checks are performed
	  on the type level at compilation time, not adding any
	  overhead to the execution of our code.
	</para>

	
	<screen>
Prelude Data.TypeLevel> :m +Data.Param.FSVec
Prelude Data.TypeLevel Data.Param.FSVec>  $(vectorTH [1::Int,2,3]) ! d0
1
Prelude Data.TypeLevel Data.Param.FSVec>  $(vectorTH [1::Int,2,3]) ! d7
&lt;interactive&gt;:1:0:
    Couldn't match expected type `LT' against inferred type `GT'
    When using functional dependencies to combine
      Trich D7 D3 GT,  
      [..]
	</screen>
	
	
	<para>
	  <code>vectorTH</code> is a Template Haskell function to
	  create vectors out of lists, we will get back to why TH is
	  needed later. <code>d0</code> and <code>d7</code> are
	  declared as <code>undefined</code> (bottom) and force the
	  inference of the <code>D0</code> and <code>D7</code>
	  type-level values.  Note that the explicit type signatures
	  are needed due to Haskell's monomorphism restriction, in the
	  general non-interactive code does not need this kind of type
	  annotations.
	</para>

	<warning>
	 Using numerical literals instead of the
	 <code>undefined</code> values (e.g. 0 and 7 instead of
	 <code>d0</code> and <code>d7</code>) is a very common error.
	</warning>
	
	<para>
	  Here are two further examples using <code>head</code>.
	</para>

	<screen>
Prelude Data.TypeLevel Data.Param.FSVec> Data.Param.FSVec.head $(vectorTH [1::Int,2,3])
1
Prelude Data.TypeLevel Data.Param.FSVec> Data.Param.FSVec.head empty

&lt;interactive&gt;:1:0:
    No instance for (Data.TypeLevel.Num.Sets.PosI D0)
      arising from a use of `Data.Param.FSVec.head'
	</screen>
	
	<para>
	  Again, attempting to obtain the head of an empty vector triggers a compile-time error.
	</para>
	
	<para>
	  Even if FSVec offers many nice features, it also has a few problems.
	</para>
      </section>
      
      <section>
	<title><code>FSVec</code> issues</title>

	<orderedlist>
	  <listitem>
	    <para>
	      Some functions such as <code>filter</code> cannot be
	      implemented. One can think about something along the
	      lines of:
	    </para> 
	    <programlisting language="haskell">
filter :: (a -> Bool) -> FSVec s a -> FSVec s2 a
	    </programlisting>
	      
	    <para>
	      However, the size of the output vector (<code>s2</code>) cannot be precalculated
	      statically.
	    </para>
	  
	  </listitem>
	  <listitem>
	    <para>
	      Since <code>FSVec</code> is an abstract data type,
	      pattern matching is lost, but that is the general case
	      in vector implementations
	      <footnote>
		<para>
		  We tried to implement pattern matching using the
		  <link
		      xlink:href="http://www.haskell.org/ghc/dist/current/docs/users_guide/template-haskell.html#th-quasiquotation">new
		  Quasiquoting mechanism in GHC</link> <link
		  xlink:href="http://www.haskell.org/pipermail/template-haskell/2008-February/000655.html">
		  without success</link>.
		</para>
	      </footnote>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      It is difficult to build a vector from a list. Again, the first thing one would
	      think of would be
	    </para>
	    <programlisting language="haskell">  
vector :: Nat s => [a] -> FSVec s a
	    </programlisting>
	    
	    <para>
	      However, since <code>s</code> would be a different type
	      depending on the length of <code>[a]</code>, this is not
	      a valid Haskell function.  <code>s</code> is
	      existentially quantified, a feature not supported
	      directly by Haskell98.
	    </para>

	    <para>
	      In addition, since the list-length is a run-time
	      condition, it is impossible to guess at compile
	      time.
	    </para>
	    
	    <para>
	      However, there are a few workarounds which are already
	      included in the library:
	    </para>
	    
	    <orderedlist>
	      <listitem>
		<para>
		  As suggested in Eaton's <link
		  xlink:href="http://ofb.net/~frederik/vectro/draft-r2.pdf">Statically
		  Typed Linear Algebra in Haskell</link>, emulate an
		  existential through <link
		  xlink:href="http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style">CPS</link>
		  (Continuation passing style). CPS is a style of
		  programming where functions never return values, but
		  instead take an extra parameter which they give
		  their result to.
		</para>
		
		<programlisting language="haskell">
vectorCPS :: Nat s => vectorCPS :: [a] -> (forall s. Nat s => FSVec s a -> w) -> w
		</programlisting>

		<para>
		  Note that the <code>forall</code> keyword is due to  using Rank2 types 
		  to emulate the existential. You don't
		  really need to understand how they work but just know to use
		  vectorCPS. Here is an example:
		</para>
		
		<screen>
$ ghci
Prelude> :m +Data.Param
Prelude Data.Param> (vectorCPS [1,2,3,4]) Data.Param.length
4
		</screen>
		
		<para>
		  Note that length is passed to the result of <code>vectorCPS</code> and not the
		  other way around.
		</para>
		
	      </listitem>
	    
	      
	      <listitem>
		<para>
		  Unsafely provide the length of the resulting vector:
		</para>
		
		<programlisting language="haskell">
unsafeVector :: Nat s => s -> [a] -> FSVec s a
		</programlisting>
	    
		<para>
		  <code>unsafeVector</code> does not suffer the
		  "existential type" problem of <code>vectorCPS</code>,
		  however it can happen that the dynamic length of the
		  list does not match the provided length (that is why the
		  function name has an "unsafe" prefix). Furthermore if
		  that is the case, we will only be able to know at
		  runtime.
		</para>
		
		<programlisting language="haskell">
Prelude Data.Param> :m +Data.TypeLevel
Prelude Data.Param Data.TypeLevel> unsafeVector d8 [1,2]
*** Exception: unsafeVector: dynamic/static length mismatch
Prelude Data.Param Data.TypeLevel> unsafeVector d2 [1,2]
&lt;1,2&gt;
		</programlisting>	    
	      </listitem>
	
	      <listitem>
		<para>
		  Template Haskell.
		</para>
		
		<para>
		  This is the preferred solution. The only problem is that, of course,
		  the TH extension is required (but we already had that dependency in ForSyDe) and you
		  can only use it with lists which are available at compile time (which,
		  for the general case of ForSyDe designs should not be a problem).
		</para>
		
		<screen>
$ ghci -XTemplateHaskell
Prelude> :m +Data.Param
Prelude Data.Param> $(vectorTH [1 :: Int,2,3,4])
Prelude Data.Param> :t $(vectorTH [1 :: Int,2,3,4])
$(vectorTH [1 :: Int,2,3,4]) :: (Num t) => FSVec Data.TypeLevel.Num.Reps.D4 t
		</screen>
		
	      </listitem>
	      
	    </orderedlist>
	  </listitem>
	</orderedlist>
	 	
	
	
      </section>
    </appendix>
  
</article>
