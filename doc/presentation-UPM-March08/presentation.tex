\documentclass{beamer}

% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.



% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 


\mode<presentation>
{
  \usetheme{Madrid}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}


\usepackage{listings}
\usepackage[english]{babel}

% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


%signals, used in Ingo's figures
\newcommand{\signal}[1]{$\overrightarrow{#1}$}

\graphicspath{{../report/figures/}{figures/}}

% grey for the listings


% settings for the listings
\lstset{language=Haskell,
  linewidth=.9\linewidth,
  stringstyle=\ttfamily,
  basicstyle=\scriptsize\ttfamily,
  frame=lines,
  frameround=ffff,
  backgroundcolor=\color[rgb]{.9,.9,1}}


\title%[Short Paper Title]  (optional, use only with long paper titles)
{ForSyDe}

\subtitle{Rising the abstraction level in System Design}

\author[A.Acosta] % (optional, use only with lots of authors)
{Alfonso Acosta\\
\footnotesize \href{mailto:alfonsoa@kth.se}{\nolinkurl{alfonsoa@kth.se}}}

% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute[KTH] % (optional, but mostly needed)
{SAM/ECS/ICT/KTH\\Royal Institute of Technology, Stockholm}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date%[CFP] % (optional, should be abbreviation of conference name)
{March 27th, 2008}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

\subject{Compilers}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

\pgfdeclareimage[height=0.5cm]{university-logo}{kth_cmyk}
\logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Outline}
  \tableofcontents[pausesections]
  % You might wish to add the option [pausesections]
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.


\section{Introduction to ForSyDe}

\beamerdefaultoverlayspecification{<+->}
\subsection{The abstraction gap problem}
\begin{frame}
  \frametitle{The abstraction-gap problem}
  % \framesubtitle{Subtitles are optional.}
  % - A title should summarize the slide in an understandable fashion
  % for anyone how does not follow everything on the slide itself.

  \begin{itemize}
  \item Systems designed nowadays (and electronic components in
    particular) are increasingly complex.
  
  \item Market pressure calls for two appartenly opposite constraints:
    \begin{enumerate}
    \item Efficiency $\Rightarrow$ It is required to handle low-level
      details at design time $\Rightarrow$ \textbf{low abstraction
        level}
      \begin{itemize}
      \item \textit{Example: Large layout parts of today's high
          performance processors are designed and optimized by hand.}
      \end{itemize}
    \item Low time-to-market and complex features $\Rightarrow$ It is
      preferable to avoid dealing with low-level details $\Rightarrow$
      \textbf{high abstraction level}
      \begin{itemize}
      \item \textit{Example: SoC (System on Chip) architectures embed
          multiple heterogeneous components. }
      \end{itemize}
    \end{enumerate}
  \item ForSyDe's main motivation is to solve the resulting
    abstraction gap problem
  \end{itemize}
\end{frame}

\subsection{What is ForSyDe?}
\begin{frame}
  \frametitle{What is ForSyDe?}
  %\framesubtitle{Subtitles are optional.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item ForSyDe (Formal System Design) ..
    \begin{itemize}
      \item .. is a System Design methodology
      \item .. models Systems at a high abstraction level.
      \item .. bridges the abstraction gap using a technique called 
            \textit{\textbf{transformational design refinement}}.
    \end{itemize}
  \item A system in ForSyDe is modelled as a network of cooperating
    \textit{\textbf{processes}} which  
     \begin{itemize}
      \item .. are communicated via \textit{\textbf{signals}}.
         \begin{itemize}
         \item Processes perform computations over its input signals
           and forward the results to adjacent processes through
           output signals.
         \end{itemize}
      \item .. are created from \textit{\textbf{process constructors}}.
      \begin{itemize}
      \item The creation of a process entails setting the parameters (values
        or functions) of a \textit{\textbf{process constructor}}.
      \item Those parameters determine the behaviour of the process over its
        input signals.
      \end{itemize}
    \end{itemize}
  \item Communication and computation are separated
    \begin{itemize}  
    \item Thus, time is abstracted, allowing multiple models of computation
      (Synchronous, Untimed, Discrete Time and Continuous).
    \item \textbf{To simplify this talk, a Synchronous MoC will be assumed}
    \end{itemize}
  \end{itemize}
\end{frame}

\beamerdefaultoverlayspecification{}  
\begin{frame}
  \frametitle{Key concepts (I)}
  \framesubtitle{Signals}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
    \item \textbf{Signal} 
      \begin{itemize}
      \item A (possibly infinite) sequence of events, were each event has a tag 
            and a value.
      \item All events in a signal must have values of the same type.
        \pause
      \item In ForSyDe, signals are modelled as lists of event values. Tags
        are implicitly determined by the location of the values in the list.
      \vspace{0.2cm}
      \hspace{3cm}$\overrightarrow{s} = \ll v_0,v_1,v_2,\dots \gg$
      \vspace{0.25cm}
    \pause 
    \item The interpretation of tags depends on the model of computation. 
        (e.g. in  general, identical tags in different signals don't imply equal
        times) 
      \item In the Synchronous MoC 
        \begin{itemize}
        \item the system is governed by a global clock 
        \item tags correspond to global-clock cycles (i.e each value corresponds
          to a clock cycle).
        \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Key concepts (II)}
  \framesubtitle{Processes and Process Constructors}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
    \item \textbf{Process}\hspace{2.3cm}
      \begin{minipage}{2cm}
        \input{../report/figures/Process.pdf_t}
      \end{minipage}
      \begin{itemize}
      \item Processes are defined as \textbf{pure} functions over signals.
        \begin{itemize}
        \item $p\ :\ \underbrace{S\ \times S \times\ \dots\ \times\ S}_n \rightarrow \underbrace{S\ \times S \times\ \dots\ \times\ S}_m$   
        \item $i_0 = i'_0, i_1 = i'_1, \dots i_n=i'_n \Rightarrow p(i_1,i_2,\dots,i_n) = p(i'_1,i'_2,\dots,i'_n)$
        \end{itemize}
      \end{itemize}
      \pause
      \vspace{0.5cm}
      \item \textbf{Process constructor}\hspace{1cm}
        \begin{minipage}{2cm}
        \visible<3->{\input{figures/ProcessConstructor.pdf_t}}
        \end{minipage}
        \begin{itemize}
          \vspace{0.3cm}
          \pause
          \item Creates a processes out of:
            \vspace{0.1cm}
            \begin{itemize}
            \item Values: process configuration parameter or initial state.
            \item Functions: process behaviour.
            \item Note: These functions operate over the values
              carried by signals, not over signals themselves.
            \item $p=pc(v_1,v_2,\dots,f_1,f_2,\dots)$ 
            \end{itemize}
        \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Examples}
\beamerdefaultoverlayspecification{<+->}
\begin{frame}
  \frametitle{Primitive Process-Constructor Examples}
  %\framesubtitle{Processes and Process Constructors}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item \textbf{$mapSY$} primitive process-constructor
    \begin{center}
      \input{../report/figures/mapSY.pdf_t}
    \end{center}
    $$mapSY(f)(\ll v_0,v_1,v_2,\dots \gg) = \ll f(v_0),f(v_1),f(v_2),\dots \gg $$  
  \item \textbf{$delaySY_k$} primitive process constructor
    \begin{center}
      \visible<2->{\input{../report/figures/delaySY.pdf_t}}
    \end{center}
    $$delaySY_k(\ll v_0,v_1,v_2,\dots \gg) = \ll \underbrace{s_0,s_0,s_0,\dots}_k,v_0,v_1,v_2,\dots \gg $$  
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{More Examples}
  %\framesubtitle{Processes and Process Constructors}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item The \textbf{$sourceSY$} derived process constructor
    \begin{center}
      \input{../report/figures/sourceSY.pdf_t}
    
    $sourceSY(f,s_0) = \ll s_0,f(s_0),f(f(s_0)),f(f(f(s_0))),\dots \gg $  
    \end{center}

  \item Sample use of a process constructor: the trivial $plus1$ process
    \begin{center}
      \visible<2->{\input{../report/figures/plus1.pdf_t}}
    \end{center}
    $$plus1 = mapSY(+1)$$  

\end{itemize}
\end{frame}



\beamerdefaultoverlayspecification{<+->}

\subsection{Simplified Design Flow}
\begin{frame}
  \frametitle{Simplified Design Flow}
  %\framesubtitle{Simplified Design Flow}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \beamerdefaultoverlayspecification{}
  \only<1>{
    \centering
    \pgfimage[height=6cm]{../presentation/figures/ForSyDe}
  }
  \begin{columns}
    \column{.62\textwidth}
    \only<2>{
      \begin{enumerate}[0)]
      \item The designer creates the \textbf{specification model} as a
        network of processes.
        
        \vspace{.5cm}
        
        \hspace{.5cm}\input{../report/figures/ConcurrentProcesses.pdf_t}
      \end{enumerate}
    }
    \only<3>{
      \begin{enumerate}[1)]
      \item \textbf{Transformational refinement}
        \begin{itemize}
        \item The \textbf{specification model}
          is transformed into a lower-level \textbf{implementation model}
        \item This stage is in charge of bridging the abstraction gap
          using transformation rules.
          \item Rules can be
          \begin{itemize}
          \item semantic preserving (automatic)
          \item non-semantic preserving (require interaction with the designer).
          \end{itemize}
          \item Relies on the formal foundations of ForSyDe.
        \item Theoretically designed but not yet implemented.
        \end{itemize}
      \end{enumerate}
    }
    \only<4>{
      \begin{enumerate}[2)]
      \item \textbf{Implementation Mapping}
        \begin{itemize}
        \item Transforms the \textbf{implementation model} into
          an architecture-specific implementation
          \begin{itemize}
          \item Software: C, C++ $\dots$
          \item Hardware: VHDL, SystemC, Verilog $\dots$
          \item Special cases: Simulation, Verification.
          \end{itemize}
        \item Current lack of automatization of (1) entails
          working with the \textbf{specification model} directly
        \item Implemented mappings: Simulation, VHDL (in progress)
        \end{itemize}
      \end{enumerate}
    }
    \column{.38\textwidth}
    \pgfimage<2->[height=6cm]{../presentation/figures/ForSyDe}
  \end{columns}
\end{frame}

\beamerdefaultoverlayspecification{<+->}

\subsection{Initial implementation of ForSyDe}
\begin{frame}
  \frametitle{Initial implementation of ForSyDe (I)}
  %\framesubtitle{Shallow embedding.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.

  \begin{itemize}
  \item The specification models were initially expressed in a
    \textbf{shallow} Haskell-embedded DSL (\textit{Domain Specific
      Language})
  \item A DSL, as opposed to a general purpose
    programming language (C,C++,Ada, Haskell) is designed for a specific task.
    \begin{itemize}
    \item Examples: YACC, Postscript, GraphViz, VHDL ...   
    \end{itemize}
  \item An Embedded DSL  is implemented inside
    a general purpose programming language (called host language), as a library.
  \item The embedding can be shallow or deep
    \begin{itemize}
    \item Shallow: The data structures supporting the embedded
      language only reflect semantics.
    \item Deep: The data structures supporting the embedded language reflect
       the structure of the program which created them.
    \end{itemize}
  \item The embedded approach has some advantages and disadvantages
    \begin{itemize}
    \item The host language plus all its surrounding machinery
      (compilers, libraries ..) can be reused.
    \item The syntax and semantics of the two languages (embedded and host)
      might differ.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initial implementation of ForSyDe (II)}
  %\framesubtitle{ForSyDe's Implementation.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  
  \begin{itemize}
  \item Why Haskell?
    \begin{itemize}
      \pause
    \item Strongly-typed: DSLs are easy to embed.
      \pause
    \item Lazy: infinite data structures are natively supported.
      \begin{itemize}
      \item Signals can be easily shallow-embedded with a type isomorphic to 
        lists.
\begin{lstlisting}
      data Signal a = NullS | a :- Signal a
\end{lstlisting}
      \end{itemize}
      \pause
    \item Purely functional with higher-order functions: 
      \begin{itemize}
      \item Process constructors are just pure, higher-order functions after all.
\begin{lstlisting}
      mapSY :: (a -> b) -> Signal a -> Signal b
      mapSY _ NullS	= NullS
      mapSY f (x:-xs)	= f x :- (mapSY f xs)
\end{lstlisting}
      \item Haskell is particularly good for creating function
        combinators, useful to create process connection patterns.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Current ForSyDe's implementation details}
\subsection{The compilation problem}
\begin{frame}
  \frametitle{The compilation problem}
  %\framesubtitle{ForSyDe's Implementation.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  
  \begin{itemize}
  \item The initial \textbf{shallow} embedding only allows simulating
    the models (The \texttt{Signal} type is not aware of how
    the system was built).
  \item We want to be able to implement the transformational
    refinement and implementation mapping stages without
    losing the ability of simulating our models.
  \item Alternatives
    \begin{itemize}
    \item Standalone Haskell compiler: excessive and unfeasible given
      our development resources.
    \item Creating a backend for an existing compiler: slightly less excessive and
      unfeasible.
    \item Keep the shallow embedding for simulation and use a static
      analyzer for compilation: very difficult without restricting how the
      host language is used.
    \item Deep embedding plus embedded compiler: chosen solution.
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Deep Embedding + Embedded compiler}
\begin{frame}[fragile]
  \frametitle{Deep Embedding + Embedded compiler}
  %\framesubtitle{ForSyDe's Implementation.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item Goal: Create a new deep-embedded \texttt{Signal}, aware of
    of the system structure.
    \begin{itemize}
    \item The new \texttt{Signal} will be the intermediate representation of
      an embedded compiler, in charge of the implementation mapping.
    \end{itemize}
    \pause
  \item A possible simplified solution (for a structural hardware
    design language).
\begin{lstlisting}   
    data Signal = Comp String [Signal] 
    inv, latch :: Signal -> Signal -- sample primitives 
    inv s = Comp "inv" [b] -- inverter primitive
    latch s = Comp "latch" [s] -- latch primitive
    toggle :: Signal -- sample circuit
    toggle = let o = inv (latch o) in o      
\end{lstlisting}
    \pause
  \item Problems:
    \begin{itemize}
      \pause
    \item Detecting sharing between components (there is no way to detect
      the loop in \texttt{toggle}).
      \pause
    \item ForSyDe signals are Polymorphic: how to represent polymorphism?
      \pause
    \item ForSyDe is behavioural: how to store functions in \texttt{Signal} for
      later translation?
    \end{itemize}
  \end{itemize}
\end{frame}


\subsection{The Sharing Problem: Observable Sharing}
\begin{frame}[fragile]
  \frametitle{The Sharing Problem: Observable Sharing}
  %\framesubtitle{ForSyDe's Implementation.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\vspace{-0.4cm}
  \begin{itemize}
  \item Explicit tagging: the designer provides a unique label for each
    component.
\begin{lstlisting}   
    type Label = String
    data Signal = Comp Label String [Signal]
    toggle = let o = inv "tinv" (latch "tlatch" o) in o      
\end{lstlisting}
    \begin{itemize}
      \pause
    \item Artificial tag syntax, uniqueness is not guaranteed.
    \end{itemize}
    \pause
  \item Transform \texttt{Signal} into a monad which generates 
    unique labels.
    \begin{itemize}
    \item Guaranteed uniqueness but inconvenient monadic syntax.
    \end{itemize}
    \pause
  \item Observable sharing: link components through unmutable references
\begin{lstlisting}   
    data Ref a = Ref (IORef a) deriving Eq
    newRef = Ref.unsafePerformIO.newIORef
    data Signal = Comp String [Ref Signal]      
\end{lstlisting}
    \begin{itemize}
      \pause
    \item Pros: Guaranteed uniqueness without inconvenient syntax
    \item Cons: Impure extension
      \begin{itemize}
        \pause
        \item However, referential transparency will be preserved if sharing is
          (all known Haskell compilers are based in graph reduction).
      \end{itemize}
    \end{itemize}
  \end{itemize}    
\end{frame}

\subsection{The Polymorphism Problem: Dynamic Types}
\begin{frame}[fragile]
  \frametitle{The Polymorphism Problem: Dynamic Types}
  %\framesubtitle{ForSyDe's Implementation.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\vspace{-0.4cm}
  \begin{itemize}
  \item So far we have solved the sharing problem, but how to take
    polymorphism in account?
\begin{lstlisting}   
-- phantom parameter to ensure type-consistency
data Signal a = Signal PrimSignal 
-- first attempt, incorrect
data PrimSignal = MapSY (a->b) (Ref PrimSignal) ...
mapSY :: (a->b) -> Signal a -> Signal b
\end{lstlisting}
\pause
  \item Solution: Dynamic types.
      \begin{lstlisting}
class Typeable a where
  typeOf :: a -> TypeRep
toDyn :: Typeable a => a -> Dynamic
fromDynamic :: Typeable a => Dynamic -> Maybe a

-- correct
data PrimSignal = MapSY Dynamic (Ref PrimSignal) ...
mapSY :: (Typeable a, Typeable b) => 
         (a->b) -> Signal a -> Signal b
   \end{lstlisting} 
  \end{itemize}    
\end{frame}


\subsection{Deep-embedding process-constructor parameters}
\begin{frame}[fragile]
  \frametitle{Deep-embedding process-constructor parameters}
  %\framesubtitle{ForSyDe's Implementation.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\vspace{-0.4cm}
  \begin{itemize}
  \item The value of the process constructor parameters is not enough,
    the compiler needs their AST for later translation.
    \pause
  \item Solution: Template Haskell (compile-time metaprogramming extension)
\begin{lstlisting}
[d| decs |] :: Q [Dec] -- lift the AST of the enclosed declarations 
$(exp) -- splice declarations or expressions
-- exp must be a Haskell expression of type (Q Exp) or (Q [Dec]) 
\end{lstlisting}
\pause    
\begin{lstlisting}
-- the Dynamic value is kept for simulation
data PrimSignal = MapSY Dynamic [Dec] (Ref PrimSignal) ...
mapSY :: (Typeable a, Typeable b) => 
         ProcFun (a->b) -> Signal a -> Signal b
newProcFun :: Q [Dec] -> Q Exp
\end{lstlisting} 
\item Example: $plus1$
  \pause
  \begin{overprint}
    \onslide<1-3>
\begin{lstlisting}
plus1 :: (Typeable a, Num a) => Signal a -> Signal a
plus1 = mapSY (+1)
\end{lstlisting}
\onslide<4>
\begin{lstlisting}
plus1 :: (Typeable a, Num a) => Signal a -> Signal a 
plus1 = mapSY p1
 where p1 = $(newProcFun [d| doPlus1 :: Num a => a -> a
                             doPlus1 a = a + 1          |])
\end{lstlisting}
\end{overprint}
  \end{itemize}    
\end{frame}

\subsection{Components}

\begin{frame}[fragile]
  \frametitle{Components}
  %\framesubtitle{Components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item Similarly to HDLs like VHDL, ForSyDe has support for
    hierarchical design through components.  
    \onslide<2->
  \item
  Let's see a simple example. Design a serial adder using components in 5 
  simple steps.
  \visible<2->{\pgfimage[width=10cm]{../presentation-Jan08/figures/SeqAddFour}}
  \end{itemize}
  
  
  \vspace{-0.7cm}
  \begin{overprint}
   \onslide<3>
   \begin{enumerate}[1)]
   \item Create a process function which adds one to its input 
    \begin{lstlisting}
  addOnef :: ProcFun (Int -> Int)
  addOnef = $(newProcFun [d| addOnef :: Int -> Int 
                             addOnef n = n + 1 |]
    \end{lstlisting}
    \end{enumerate}
   
   \onslide<4>
   \begin{enumerate}[2)]
   \item Create a system function corresponding to the unit adder
   \begin{lstlisting}
  addOneProc :: Signal Int -> Signal Int
  addOneProc = mapSY addOnef
   \end{lstlisting}
   \end{enumerate}
   
   \onslide<5>
   \begin{enumerate}[3)]
   \item Subsystem definition associated to the unit adder
   \begin{lstlisting}
 addOneSysDef :: SysDef (Signal Int -> Signal Int)
 addOneSysDef = $(newSysDef 'addOneProc ["in1"] ["out1"])
   \end{lstlisting}
   \end{enumerate}


   \onslide<6>
   \begin{enumerate}[4)]
   \item Create the main system function
   \begin{lstlisting}
  addFour :: Signal Int -> Signal Int
  addFour = $(instantiate "addOne3" 'addOneSysDef) .
            $(instantiate "addOne2" 'addOneSysDef) .
            $(instantiate "addOne1" 'addOneSysDef) .
            $(instantiate "addOne0" 'addOneSysDef)
   \end{lstlisting}
   \end{enumerate}

   \onslide<7>
   \begin{enumerate}[5)]
   \item Finally, build the main system definition
   \begin{lstlisting}
  addFourSys :: SysDef (Signal Int -> Signal Int)
  addFourSys = $(newSysDef 'addFour ["in1"] ["out1"])
   \end{lstlisting}
   \end{enumerate}

\end{overprint}

\end{frame}


\begin{frame}
  \frametitle{Specification Level Design Flow Using Components}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\vspace{-0.2cm}
\begin{center}
\pgfimage[height=8cm]{../presentation-Jan08/figures/compflow}
\end{center}

\end{frame}

\section<presentation>*{Further Reading}

\begin{frame}
  \frametitle<presentation>{Further Reading}
    
%   \begin{thebibliography}{10}
    
%   \beamertemplatebookbibitems
%   % Start with overview books.

%   \bibitem{Author1990}
%     A.~Author.
%     \newblock {\em Handbook of Everything}.
%     \newblock Some Press, 1990.
 
    
%   \beamertemplatearticlebibitems
%   % Followed by interesting articles. Keep the list short. 

%   \bibitem{Someone2000}
%     S.~Someone.
%     \newblock On this and that.
%     \newblock {\em Journal of This and That}, 2(1):50--100,
%     2000.
%   \end{thebibliography}
  
%  \nocite*
%  \bibliography{presentation}
%  \bibliographystyle{unsrt}
\beamerdefaultoverlayspecification{}
\begin{thebibliography}{1}

\bibitem{forsyde:thesis}
Ingo Sander.
\newblock {\em System Modeling and Design Refinement in ForSyDe}.
\newblock PhD thesis, Royal Institute of Technology, Sweden, 2003.

\bibitem{fons:thesis}
Alfonso Acosta.
\newblock {\em Hardware synthesis in ForSyDe: The design and implementation of a Haskell-embedded ForSyDe-to-VHDL compiler}.
\newblock Master's thesis, Royal Institute of Technology, Sweden, 2007.

\bibitem{osharing}
Koen Claessen and David Sands.
\newblock Observable Sharing for functional circuit description.
\newblock In {\em Asian Computing Science Conference}, pages 62--73, 1999.


\bibitem{hydra:th}
John~T. O'Donnell.
\newblock Embedding a Hardware Description Language in Template Haskell.
\newblock In {\em Domain-Specific Program Generation}, pages 143--164, 2003.



\end{thebibliography}


\end{frame}


\end{document}


