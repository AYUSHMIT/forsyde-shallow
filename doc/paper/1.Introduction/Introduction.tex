
\section{Introduction}
\label{sec:Introduction}


% Intro ForSyDe modeling language 
ForSyDe is a design methodology that has been designed to raise the abstraction level of system design. It uses a behavioral system domain specific language (DSL) with polymorphic signal values, which means that signal values can be of any Haskell type.
\alfonso{I don't think we need the ``means'' clarification and maybe we should introduce the role of signals before mentioning them}

% Objectives
The initial implementation of the modeling environment was shallow-embedded in Haskell, which restricted its use to simulation and did not allow to analyse the system model. 
\alfonso{I think it should be rephrased in a nicer way and we should specifically say why only simulation was possible}

To overcome the limitations of the existing approach we decided to deep-embed ForSyDe in Haskell after studying related approaches like Lava \cite{BjeCla1998}. Of particular interest was the development of a synthesis backend to be able to automatically synthesize ForSyDe system models in the corresponding VHDL-description. 
\alfonso{What are those limitations? (we should say that compilation wasn't possible)}

The result of this work is a \emph{general technique} based on dynamic types and Template Haskell \cite{} that can be used to deep-embed DSLs in Haskell without losing the power of polymorhic types \footnote{So far values in all existing deep-embedded DSLs are monomorphic} and to describe computations in plain Haskell.
\alfonso{Rephrase, possibly using the new alternative of the abstract}
 
We successfully applied this technique for the analysis of ForSyDe systems. ForSyDe system models can be described using any Haskell type for signal values and any Haskell expression to describe computations. Depending on the restrictions of the analyzer backend, the backend can either support the full language (simulation) or a restricted subset of the language (Synthesis to VHDL). 
\alfonso{Not every signal can be used, they must be instances of Data and Typeable, but maybe its not a good idea to be so specific in the introduction.}

\section{ForSyDe}
\label{sec:ForSyDe}

ForSyDe (Formal System Design) \cite{SanJan2004a} is a design methodology that has been developed to raise the abstraction level of system design. A system is modeled as a hierarchical concurrent process network, where processes communicate via signals, as illustrated in Figure \ref{fig:SystemModel}.
\alfonso{Maybe illustrate it with an specific example from the very begining? i.e. show a concrete system with an specific purpose. e.g. a mux}

\begin{figure}[htb]
  \centering
  \resizebox{0.4\columnwidth}{!}{\input{figures/ConcurrentProcesses.pdf_t}}
  \caption{A ForSyDe system model is a hierarchical process network, where processes communicate via signals.}
  \label{fig:SystemModel}
\end{figure}

ForSyDe supports different models of computation (MoCs), which are connected via domain interfaces. The ForSyDe library contains modeling elements for the different models of computation and is written in Haskell. The current version of the deep-embedded implementation of ForSyDe uses only the synchronous model of computation, since our first objective was to be able to generate hardware from synchronous ForSyDe models.
\alfonso{Shouldn't we say that we are only going to refer to Synchronous MoC in this paper?}

The synchronous model of computation is the base for the family of synchronous languages \cite{BenBer1991}. Prominent languages are Esterel, Lustre, Signal or Lucid Synchrone. Timing is defined by the \emph{perfect synchrony hypothesis}, which implies that output events are produced synchronously with the input events. Thus the reaction of the system to the input events takes \emph{zero time}. To be able to cope with asynchronous signals or signals with different data rates, the synchronous model defines a special value 'Absent' ($\perp$), which denotes the absence of an event.   
\alfonso{is Absent that important? it is quite specific and difficult to understant wihout the proper context or an example}
\alfonso{I think at this point we should provide an example of SYncrhonous system and exmplain the key concepts (process, process constructor ... ) out of it and not the other way around (first the concept, then the example)}

ForSyDe signals are based on lists. A synchronous process takes in each activation cycle one event from each input signal and produces an event for each output signal. We use a special data type to model absent values similar to \texttt{Maybe}. Either the value is present and has a value or it is absent.
\alfonso{I think signals are modelled as infinite streams of values, which is more abstract that a list. A list is the specific data structure used to implement them}
\alfonso{Again, are absent values that important here?}

\begin{figure}[htb]
  \centering
  \resizebox{\columnwidth}{!}{\input{figures/ProcessConstructor.pdf_t}}
  \caption{A process (here \emph{mooreSY f g v}) is constructed by means of a process constructor, functions and variables.}
  \label{fig:ProcessConstructor}
\end{figure}


Leaf processes are constructed by \emph{process constructors}, which are modelled by higher-order functions in Haskell. Figure \ref{fig:ProcessConstructor} illustrates the construction of a process that models a Moore state machine in the synchronous model of computation. The process constructor determines the interface and the model of computation. The functions $f$ and $g$ define the computation of the process in form of a function for the next state ($f$) and an output function ($g$). Finally the variable $v$ gives the initial state of the process. All processes are free from side effects, but may as the process in Figure \ref{fig:ProcessConstructor} have a local internal state. Since the system model is composed of leaf processes, it is also free from side effects.
\alfonso{Should higher order functions be mentioned here? This describes how ForSyDe works in general, the implementation is going to be covered later anyway.}
\alfonso{The mooreSY example is maybe too abstract a concrete use of mooreSY would be more helpful.}
\alfonso{As I mentioned previouslym it would maybe be a good idea to start with a system example and explain all the key concepts using it.}

The concept of process constructors leads to a well-structured system model with a clear separation of communication and computation and has been the base for our work on design transformations \cite{SanJan2004a, RauSan2008a}. The initial proposal for synthesis for the shallow-embedded version of ForSyDe \cite{SanJan1999b} is an almost direct mapping  to VHDL-constructs. To create a VHDL component, process constructors are mapped to their corresponding VHDL templates and ForSyDe functions are translated to VHDL-functions. The ForSyDe process network, which is described as a set of equations, is finally translated into a network of VHDL components.  
\alfonso{I think that the shallow-embedded implementation of ForSyDe and it smapping proposal should be moved to its specific section. (We agreed on writing a section about how the shallow-embedded version of ForSyDe worked)}


% "ForSyDe descriptions can be translated to VHDL. The initial translation approach, planned for the shallow-embedded version of ForSyDe,  was based on a mapping ruleset, in charge of translating process descriptions using VHDL templates." 

 
% The concept of process constructors gives a number of benefits, which we use to our advantage in ForSyDe. Communication (process constructor) is separated from computation (functions).
%\item Since the system model uses extensively higher-order functions and function composition, it gives a solid base for formal reasoning, which we have applied for design transformations. 
%\item Process constructors can be equipped with an implementation semantics.
%\end{itemize}

% ---- Hardware Semantics of ForSyDe 







% --- Synthesis, Mapping Rules



 



 











