This chapter is aimed at introducing the end-user to the compiler
and its API.

First, a simple \textit{identity} system will be used to show how
connections are made. Then, a reasonably complex example gives further
details on how to use the compiler.

\section{Prerequisites}

In order to be able to follow this tutorial it is required to have a
working copy of:

\begin{itemize}
\item ForSyDe Standard Library with compiling support\footnote{It can be
  downloaded from
  \url{http://www.imit.kth.se/info/FOFU/ForSyDe/HDForSyDe/}.}.
\item GHC version 6.6 or higher.
\item Haskell's \texttt{mtl} (Monad Template
  Library)\footnote{Normally included in the GHC distributions. It can
    be downloaded from \url{http://hackage.haskell.org/}.}.
\end{itemize}

\section{Identity system}

\begin{figure}
\centering
\input{figures/Identity.pdf_t}
  \caption{Identity system}
  \label{fig:identity}
\end{figure}

As an example of how to make connections within a model, an
\textit{Identity} system (figure \ref{fig:identity}) will be built.

The system could not be simpler: It has six inputs and six outputs
which are connected in parallel.


First, the name of the module is declared and the required libraries
are imported.

\begin{lstlisting}
module Identity
import HD
\end{lstlisting}

Then the input and output ports are defined.

\begin{lstlisting}
idIn :: InPort
idIn = mkInPort 6 [("input0",Int),
                   ("input1",Int),
                   ("input2",Int),
                   ("input3",Bool),
                   ("input4",Bool),
                   ("input5",Bool)]


idOut :: OutPort
idOut = mkOutPort 6 [("output0",Int),
                     ("output1",Int),
                     ("output2",Int),
                     ("output3",Bool),
                     ("output4",Bool),
                     ("output5",Bool)]
\end{lstlisting}

The type of the ports is not significant, any other type combination would
have been valid.


Using the full power of Haskell, those ports could have been defined as

\begin{lstlisting}
iname  = "input"
oname  = "output"
nInts  = 3
nBools = 3

(idIn,idOut) = (portDesc iname, portDesc oname)
  where types          = replicate nInts Int ++ replicate nBools Bool
        indexes        = iterate (+1) 0
        portDesc  name = zipWith3 join (repeat name) indexes
        join  id ix t  = (id  ++ show ix, t)
\end{lstlisting}
permitting to easily change the number of inputs/outputs and their
names. This example can be a bit obscure, but shows how the embedded
compilation model permits making use of Haskell features.


Once the ports are defined, the circuit description can be written. A
way to do so is using the \texttt{connectIx} function, which connects
an input-port signal with an output-port one, and returns the modified
output port.

\begin{lstlisting}
idCirc :: Circuit -- (InPort -> OutPort)                 
idCirc inP = (connectIx "input5" inP "output5".
              connectIx "input4" inP "output4".
              connectIx "input3" inP "output3".
              connectIx "input2" inP "output2".
              connectIx "input1" inP "output1".
              connectIx "input0" inP "output0") idOut
\end{lstlisting}

\texttt{connectIx} can use the signal identifiers as index, but it can
also use numerical indexes or both.

\begin{lstlisting}
idCirc :: Circuit
idCirc  inP = (connectIx 5          inP "output5" .
               connectIx "input4"   inP 4         .
               connectIx 3          inP 3         .
               connectIx "input2"   inP "output2" .
               connectIx "input1"   inP "output1" .
               connectIx "input0"   inP "output0" ) idOut
\end{lstlisting}

The advantage of using numeric indexes is that they work with an
input port independently of its signal identifiers.

\texttt{connectIx} is easy to understand but makes the design
quite verbose.

Subports are a better option. A subport is a range of signals within
port. The identity circuit can be built making use of them.

\begin{lstlisting}
idCirc :: Circuit 
idCirc inP = connectSP 
                  ("input0" , "input5" ) inP        
                  ("output0", "output5") idOut
\end{lstlisting}

\texttt{connectSP} is used to connect signals \texttt{"input0"} to
\texttt{"input5")} at the input port with signals \texttt{"output0"}
to \texttt{"output5"} at the output port.

\texttt{connectSP} also admits mixing numbers and identifiers in the
same way as \texttt{connectIx}:



\begin{lstlisting}
idCirc :: Circuit 
idCirc inP = connectSP ("input0", "input5")  inP
                       (0       , 5       )  idOut
\end{lstlisting}

Another possible option is to omit the subport of the origin or
destination. In way, it will be implicitly assumed that all the
signals of the of the input (output) port take part in the connection.

One can omit the input subport $\dots$
\begin{lstlisting}
idCirc :: Circuit 
idCirc3 inP = connectFrom inP
                          ("output0", "output5") idOut
\end{lstlisting}
$\dots$ or the output subport
\begin{lstlisting}
idCirc :: Circuit 
idCirc inP = connectTo (0, 5) inP
                       idOut

\end{lstlisting}


Lastly, there is a more elegant way to connect all inputs and outputs
of two ports at once.

\begin{lstlisting}
idCirc :: Circuit 
idCirc inP = inP `connect` idOut
\end{lstlisting}


So far the circuit of the system was defined. However, the circuit
needs to be transformed to a \texttt{Block} before translating the
design to VHDL.

\begin{lstlisting}
idBlock :: Block
idBlock = mkBlock "identity" idIn idCirc
\end{lstlisting}

\texttt{mkBlock} takes an identifier, an input port and the circuit, and
returns the corresponding \texttt{Block}.

\subsection{Compiling the model}

To compile the model to VHDL simply

\begin{enumerate}[1)]
\item Save the model in a file named \texttt{Identity.hs}
\item Execute ``\texttt{ForSyDe Identity.hs}'' making sure that the
  \texttt{bin/} directory of ForSyDe's Library is in the execution
  path\footnote{If you are a windows user this does not apply to you.
    Load the model in \texttt{ghci} making sure that the \texttt{src/}
    directory of ForSyDe's library is in the import directory list
    (\texttt{-i} flag).}.
\item From \texttt{ghci}'s prompt, type
\begin{verbatim}
*Identity> writeVHDL idBlock
Writing VHDL code to identity.vhd ... done!
\end{verbatim}
\end{enumerate}

\section{A more complex system}
\begin{figure}
\centering
\input{figures/Complex.pdf_t}
  \caption{A more complex system}
  \label{fig:complex}
\end{figure}
Figure \ref{fig:complex} illustrates a still trivial but slighty
more complex system descripotion.

\begin{itemize}
\item  It has 4 inputs and 5 outputs. 
\item The system checks if \signal{i_0} and \signal{i_1} are opposite
  and connects the result to \signal{o_0}.
\item Signal \signal{i_2} is compared with 0. The result is connected to
  \signal{o_2}.
\item Input \signal{i_2} is directly connected to \signal{o_1}.
\item Output \signal{i_3} is connected to a cycle counter.
\item The rest of inputs and outputs remain unused.
\end{itemize}


First, the name of the module is declared together with the import list

\begin{lstlisting}
{-# OPTIONS_GHC -fth #-}
-- -fth is required due to the use of Template Haskell 
module MoreComp where
import HD
import SynchronousLib (mapSY, zipWithSY, sourceSY)
\end{lstlisting}

Then, the ports of the system are declared:

\begin{lstlisting}
MCIn = mkInPort 4 [("in0",Int),
                   ("in1",Int),
                   ("in2",Int),
                   ("in3",Bool)]

MCOut = mkOutPort 5 [("out0",Bool),
                     ("out1",Int),
                     ("out2",Bool),
                     ("out3",Int),
                     ("out4",Int)]
\end{lstlisting}

Then, the code related to the computations performed within the system
is written.

This function performs the comparison with zero:

\begin{lstlisting}
isZero :: HDSignal Int -> HDSignal Bool
isZero = mapSY doIsZero
 where doIsZero = $(mkHDFun [d| doIsZero :: Int -> Bool
                                doIsZero a = a == 0 |])
\end{lstlisting}

Note the use of Template Haskell.

In order to check if two values are opposite, first they will be
added and then, the result will be compared with zero (for which
\texttt{isZero} is reused).

\begin{lstlisting}
plus :: HDSignal Int -> HDSignal Int -> HDSignal Int
plus = zipWithSY doPlus
 where doPlus = $(mkHDFun [d| doPlus :: Int -> Int -> Int
                              doPlus a b = a + b          |])


areOpposite :: HDSignal Int -> HDSignal Int -> HDSignal Bool
areOpposite a b = isZero (plus a b)
\end{lstlisting}

The only computing part of the system is the cycle counter:

\begin{lstlisting}
cycleCounter :: HDSignal Int
cycleCounter = sourceSY plus1 1
     where plus1 = $(mkHDFun [d| plus1 :: Int -> Int
                                 plus1 i = i + 1     |])
\end{lstlisting}
 
The initial value of the counter is 1. Once the system is started
\texttt{plus1} will be executed in every cycle, incrementing the value
of the counter.

The only thing left to complete the system is creating the connections
within the circuit and producing a block from where to generate VHDL.


The circuit can be defined as follows:

\begin{lstlisting}
MCCircuit :: InPort -> OutPort
MCCircuit ip = 
  (supplySig (plugSig2 "in0" "in1" ip areOpposite) "out0".
   supplySig (plugSig  "in2"       ip isZero     ) "out2".
   connectIx "in2" ip                              "out1".
   supplySig cycleCounter                          "out3") MCOut
\end{lstlisting}

\texttt{connectIx} was already introduced in previous section. However,
there are some new functions which must be commented:

\begin{itemize}
\item \texttt{supplySig} supplies a signal to an output port. The
  output port changes and for that reason a new port is returned.
\item \texttt{plugSig} plugs a function to a signal  coming from an input
  port.
\item \texttt{plugSig2} is the two-argument variant of
  \texttt{plugSig}. It plugs a two-argument function to two signals of
  an input port. 
\end{itemize}

Finally, a \texttt{Block} is created from which the model can be
translated to VHDL.

\begin{lstlisting}
MCBlock :: Block
MCBlock = mkBlock "MC" MCIn MCCircuit
\end{lstlisting}

\begin{verbatim}
*MoreComp> writeVHDL MCBlock
Writing VHDL code to MC.vhd ... done!
\end{verbatim}

