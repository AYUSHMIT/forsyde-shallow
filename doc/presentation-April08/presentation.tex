\documentclass{beamer}

% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.



% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 


\mode<presentation>
{
  \usetheme{Madrid}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}


\usepackage{listings}
\usepackage[english]{babel}

% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


%signals, used in Ingo's figures
\newcommand{\signal}[1]{$\overrightarrow{#1}$}

\graphicspath{{../report/figures/}{figures/}}

% grey for the listings


% settings for the listings
\lstset{language=Haskell,
  linewidth=.9\linewidth,
  stringstyle=\ttfamily,
  basicstyle=\scriptsize\ttfamily,
  frame=lines,
  frameround=ffff,
  backgroundcolor=\color[rgb]{.9,.9,1}}


\title%[Short Paper Title]  (optional, use only with long paper titles)
{ForSyDe's embedded compiler}

\subtitle{Second development stage results.}

\author[A.Acosta] % (optional, use only with lots of authors)
{Alfonso Acosta\\
\footnotesize \href{mailto:alfonso.acosta@gmail.com}{\nolinkurl{alfonso.acosta@gmail.com}}}

% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute[KTH] % (optional, but mostly needed)
{ICT/ECS\\Royal Institute of Technology, Stockholm}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date%[CFP 2003] % (optional, should be abbreviation of conference name)
{April 21st, 2008}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

\subject{Compilers}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

\pgfdeclareimage[height=0.5cm]{university-logo}{kth_cmyk}
\logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Outline}
  \tableofcontents[pausesections]
  % You might wish to add the option [pausesections]
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\beamerdefaultoverlayspecification{}
\section{General Goal Review}
\begin{frame}
\frametitle{General Goal Review}
% \framesubtitle{Subtitles are optional.}
% - A title should summarize the slide in an understandable fashion
% for anyone how does not follow everything on the slide itself.
\begin{itemize}
\item During this second stage it was agreed to attain this goals:
  \begin{itemize}
\pause
  \item Include support for the Untimed and Discrete MoCs.\visible<9->{\pgfimage[height=10pt]{../presentation-Jan08/figures/cross}}
    \pause      
  \item Improve and extend the VHDL backend (only Synchronous Moc).\visible<9->{\pgfimage[height=10pt]{../presentation-Jan08/figures/tick}}
    \pause
  \item Study and implementation of a graphical backend.\visible<9->{\pgfimage[height=10pt]{../presentation-Jan08/figures/tick}}
    \pause
  \item Test suite (Jun and Ingo involved)\visible<9->{\pgfimage[height=10pt]{../presentation-Jan08/figures/cross}}
  \end{itemize}
\pause
\item But, at the same time ...
  \begin{itemize}
  \item I was asked to prioritize the VHDL backend implementation over the other goals.
    \pause
  \item The Haskell-embedded implementation of \texttt{Vector} didn't match the semantics of ForSyDe, which requires fixed-sized vectors, posing an important design problem (specially for the VHDL backend).
  \end{itemize}
\pause
\item  As a result, due to Haskell's lack of subtyping and dependent types, the implementation and integration of vectors
  was tricky, difficult and time-consuming, affecting the initial plan.
\pause
\item Implementation of fixed-sized vectors \visible<9->{\pgfimage[height=10pt]{../presentation-Jan08/figures/tick}} 
\item Improved simulation backend (lazy and zero-input systems) \visible<9->{\pgfimage[height=10pt]{../presentation-Jan08/figures/tick}}
\end{itemize}  
\end{frame}

\section{Result details}

\subsection{Simulation improvements}

\begin{frame}
  \frametitle{Simulation improvements}
  %\framesubtitle{Components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item
  Previously, simulation was strict and didn't admit systems without inputs.
   \pause
  \item
    Now simulation is lazy and there is no need to create fake inputs to
simulate systems without them.
  \item As a sweet side-effect, it is no longer necessary to supply
    lists of equal length to the simulation function.
  \pause
  \item
  Let's see two examples: \texttt{Counter}, and \texttt{Add} systems.
 
\end{itemize}

\end{frame}

\subsection{Fixed-sized vectors}
\begin{frame}[fragile]
  \frametitle{Fixed-sized vectors (I)}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\begin{itemize}
\item ForSyDe processes have a constant number of input and output
  signals.
  \pause
\item However, type \texttt{Vector}  violates that constraint ...

\begin{lstlisting}
zipWithxSY :: (Vector a -> b) -> Vector (Signal a) -> Signal b
unzipxSY :: Signal (Vector a) -> Vector (Signal a)
\end{lstlisting}
  \pause
\item Solution: use fixed-sized vectors.
  \begin{itemize}
  \item Tricky: Haskell lacks direct support for subtyping or dependent 
    types.
    \pause
  \item Possible through type-level programming: the size parameter
    is emulated by coding it with types.
  \item Obscure and difficult technique, but it makes fixed-sized vectors
    possible.
    \begin{itemize}
    \item e.g. \texttt{FSVec D10 Int} is a vector of size 10 with integers
      elements
    \end{itemize}

\pause
\item
\begin{lstlisting}
zipWithxSY :: Nat s => (a -> b) -> FSVec s (Signal a) 
                    -> Signal b
unzipxSY :: Nat s => Signal (FSVec s a) 
                  -> FSVec s (Signal a)
\end{lstlisting}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fixed-sized vectors (II)}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\begin{itemize}
  \item Additional features of fixed-sized vectors
    \begin{itemize}
      \item They allow setting constraints on the vector size, which
        are checked at \textbf{compile time}
\begin{lstlisting}
fft :: (Nat s, IsPowOf D2 s) => 
       FSVec s (Complex Double) 
    -> FSVec s (Complex Double)
\end{lstlisting}
        \pause
      \item That is especially useful for bound-checking
\begin{lstlisting}
(!) :: (Pos s, Nat i, i :<: s) => FSVec s a -> i -> a        
\end{lstlisting}
      \end{itemize}
  \end{itemize}
\end{frame}

\beamerdefaultoverlayspecification{<+->}
\subsection{VHDL Backend}
\begin{frame}
  \frametitle{VHDL backend (I)}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\vspace{-0.2cm}
\begin{itemize}
\item The VHDL backend is finally functional
  \begin{itemize}
  \item All processes are supported
  \item Instances are translated into named-entity instantiations.
  \item Special emphasis was put on making error report friendly.
  \item Type support
    \begin{itemize}
    \item primitive types:
      \texttt{Bool}, \texttt{Int}\{\texttt{8},\texttt{16},\texttt{32},\texttt{64}\}, \texttt{Bit}
    \item composite types: 
      Tuples of any size, \texttt{AbstExt}, \texttt{FSVec}
    \end{itemize}
  \item Expressions supported inside \texttt{ProcFun}s
    \begin{itemize}
    \item \texttt{if} and \texttt{case} expressions
    \item Boolean expressions: \texttt{True}, \texttt{False}, \texttt{(\$\$)}, \texttt{(||)} ...      
    \item Bit logic expressions: \texttt{xor}, \texttt{(.\&.)}, \texttt{shift} ...
    \item Integral arithmetic expressions: literals (\texttt{1231}), \texttt{(+)}, \texttt{div} ...
    \item Tuple, \texttt{Bit} and \texttt{AbsExt} constructors: \texttt{Abst}, \texttt{Prst}, \texttt{H}, \texttt{L}, \texttt{(True,False)}
    \item \texttt{AbstExt} primitive functions: \texttt{isPresent}, \texttt{isAbsent} ...
    \end{itemize}
  \end{itemize}
\item What is left?
  \begin{itemize}
  \item User-defined enumeration types (difficult problem).
  \item \texttt{ProcFun} default parameters.
  \item \texttt{FSVec} primitive functions.
  \item Pattern matching.
  \end{itemize}
\end{itemize}
\end{frame}

\beamerdefaultoverlayspecification{}
\begin{frame}
  \frametitle{VHDL backend (II)}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\vspace{-0.2cm}
\begin{itemize}
\item How does the VHDL backend work?
  \begin{itemize}
  \item Example. We compile a system named \texttt{A} which uses instances 
    of systems \texttt{B} and \texttt{C}.
  \end{itemize}
\vspace{0.1cm}
\begin{center}
    \pgfimage[height=6cm]{figures/VHDL}
\end{center}
\end{itemize}
\end{frame}


\begin{frame}
  \frametitle{VHDL Backend (III)}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  \begin{itemize}
  \item Let's see two what code is generated by the VHDL for this simple
    serial adder
    \begin{center}
      \pgfimage[width=10cm]{../presentation-Jan08/figures/SeqAddFour}
    \end{center}
  \end{itemize}
\end{frame}

\beamerdefaultoverlayspecification{<+->}
\subsection{Graphical backend}
\begin{frame}
  \frametitle{Graphical backend}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\begin{itemize}
  \item Ideal output format
    \begin{enumerate}
    \item Open 
    \item Standard.
    \item Easy to parse
    \item Hierarchy support \textbf{with sharing} of hierarchy elements 
      (components). Otherwise the representation is flat in practice.
    \item Existing free viewer tool with nice node-placement and 
      edge-routing algorithms together with hierarchy browsing.
    \item Able to include all information of the system
      (process type, function arguments) i.e. not just a graphical
      format but a full representation of the system.
    \end{enumerate}
    \item Impossible to satisfy them all:
    \begin{itemize}
    \item All open netlist formats (EDIF, edaXML ...) miss 6.
    \item General graph formats:
      \begin{itemize}
        \item Graphviz and daVinci miss 2, 3, 4, 5, 6. 
        \item GraphML only misses 4 (no sharing).
      \end{itemize}
    \item Creating a custom format misses 2 and 5. 
    \end{itemize}
  \end{itemize}
\end{frame}

\subsubsection{GraphML}
\begin{frame}
  \frametitle{GraphML (I)}
  % \framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  % for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item I chose to try GraphML as a backend format because it is ...
    \begin{itemize}
    \item Open, standard and easy to parse (XML-schema based).
    \item yFiles develops visualizing software
      with impressive results supporting GraphML. 
      yEd, its graph editor is free (as in beer). 
    \item Extensible, allowing to add ForSyDe's system information to
      the graph.
    \end{itemize}
  \item Drawbacks of GraphML
    \begin{itemize}
    \item the standard doesn't cover graphical attributes (node shapes, edge types ...).
      \begin{itemize}
      \item yFiles uses its own extension to add graphical information.
      \end{itemize}
    \item It supports hierarchies (nested graphs) but does not
      directly support subgraph sharing (components).
      \begin{itemize}
      \item Can be achieved by an extension but, without using a
        custom viewer tool, it would cause losing hierarchical
        browsing.
      \end{itemize}
    \item Graphs, unlike netlists, are unaware of ports
      \begin{itemize}
        \item Input and output ports are modelled as nodes.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}



\beamerdefaultoverlayspecification{}
\begin{frame}
  \frametitle{GraphML (II)}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  \begin{itemize}
  \item Let's go through two GraphML file samples and see how yEd
    processes them.
    \begin{center}
      \hspace{-0.5cm}\begin{tabular}{cc}
        \texttt{nested.graphml} & \texttt{attributes.graphml} \\
        \pgfimage[height=5cm]{figures/nested} & \pgfimage[height=5cm]{figures/attributes} \\
      \end{tabular}
    \end{center}
  \end{itemize}
\end{frame}



\begin{frame}
  \frametitle{GraphML (III)}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  \begin{itemize}
  \item Let's see two what code is generated by the new backend in the
    case of the serial adder and how yEd interprets it
    \begin{center}
      \pgfimage[width=10cm]{../presentation-Jan08/figures/SeqAddFour}
    \end{center}
  \end{itemize}
\end{frame}

\beamerdefaultoverlayspecification{<+->}
\section{Design issues}
\begin{frame}
  \frametitle{Design issues (I)}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  \begin{itemize}
  \item What graphical/output-representation backend should be used?
    \begin{enumerate}
    \item GraphML
    \item Custom format
    \item ...
    \end{enumerate}
  \item Sharing of \texttt{ProcFun}s between processes?
    \begin{itemize}
    \item Although different processes might share the same function parameters,
      the compiler (currently) replicates their translation.
    \item Sharing of functions might lead to more obscure code (VHDL)
      and might require a \texttt{\_lib} file for the GraphML backend
    \item Processes don't normally share code.
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Design issues (II)}
  \framesubtitle{Name-clash hell.}
  % - A title should summarize the slide in an understandable fashion
  \begin{itemize}
  \item Port identifiers (\texttt{["in1","in2"]}) process
    identifiers  (\texttt{"MapSY1"}) and \texttt{ProcFun} parameters
    (\texttt{f a b = ...}) are useful for 
    \begin{enumerate}
    \item error reporting. However, processes have two problems:
      \begin{itemize}
        \item \alert{we don't have access to module location info}
        \item \alert{identifiers get obfuscated by the library}
      \end{itemize}
    \item making generated code easier to understand
    \end{enumerate}
  \item Port-identifiers can be checked for clashes at compile-time
    (TH).
  \item Process identifiers cannot. In addition, they need to be checked
    before error reporting (otherwise reports are not
    guaranteed to determine a unique process).
    \begin{itemize}
    \item \alert{requires an additional netlist traversal}
    \end{itemize}
 \item \texttt{ProcFun}s are guaranteed to be clash-free by TH.
 \item \alert{Using the same identifiers in the generated code can lead to clashes}
   e.g., VHDL backend.
   \begin{itemize}
   \item Ports: \texttt{["in1","In1","clk"]}. Case insensitive and 
        fresh names.
      \item Processes: \texttt{"MapSY1","Mapsy1"}. Case insensitive.
      \item Functions: \texttt{f aP ap tup1 (b,c)}. Case sensitive, fresh names.
      \end{itemize}
    \end{itemize}
\end{frame}

\beamerdefaultoverlayspecification{}
\section{What's next?}

\begin{frame}
  \frametitle{What's next?}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
 \begin{itemize}
 \item What should be done now?
 \item Personal proposal:
  \begin{itemize}
   \item Testing + Improve current backends.  
   \item Code cleaning.
   \item Tutorial
   \item Public release
   \item Only add new MoCs when everything is more stable and we have feedback. 
   \end{itemize}
 \end{itemize}
\end{frame}

\end{document}


