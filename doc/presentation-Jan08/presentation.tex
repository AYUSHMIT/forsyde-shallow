\documentclass{beamer}

% This file is a solution template for:

% - Talk at a conference/colloquium.
% - Talk length is about 20min.
% - Style is ornate.



% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 


\mode<presentation>
{
  \usetheme{Madrid}
  % or ...

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}


\usepackage{listings}
\usepackage[english]{babel}

% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


%signals, used in Ingo's figures
\newcommand{\signal}[1]{$\overrightarrow{#1}$}

\graphicspath{{../report/figures/}{figures/}}

% grey for the listings


% settings for the listings
\lstset{language=Haskell,
  linewidth=.9\linewidth,
  stringstyle=\ttfamily,
  basicstyle=\scriptsize\ttfamily,
  frame=lines,
  frameround=ffff,
  backgroundcolor=\color[rgb]{.9,.9,1}}


\title%[Short Paper Title]  (optional, use only with long paper titles)
{ForSyDe's embedded compiler}

\subtitle{First development stage results.}

\author[A.Acosta] % (optional, use only with lots of authors)
{Alfonso Acosta\\
\footnotesize \href{mailto:alfonso.acosta@gmail.com}{\nolinkurl{alfonso.acosta@gmail.com}}}

% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute[KTH] % (optional, but mostly needed)
{ICT/ECS\\Royal Institute of Technology, Stockholm}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date%[CFP 2003] % (optional, should be abbreviation of conference name)
{January 14th, 2008}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

\subject{Compilers}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

\pgfdeclareimage[height=0.5cm]{university-logo}{kth_cmyk}
\logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Outline}
  \tableofcontents[pausesections]
  % You might wish to add the option [pausesections]
\end{frame}


% Structuring a talk is a difficult task and the following structure
% may not be suitable. Here are some rules that apply for this
% solution: 

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

% - A conference audience is likely to know very little of what you
%   are going to talk about. So *simplify*!
% - In a 20min talk, getting the main ideas across is hard
%   enough. Leave out details, even if it means being less precise than
%   you think necessary.
% - If you omit details that are vital to the proof/implementation,
%   just say so once. Everybody will be happy with that.

\beamerdefaultoverlayspecification{}
\section{General Goal Review}
\begin{frame}
  \frametitle{General Goal Review}
  %\framesubtitle{Subtitles are optional.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item
    During this first stage it was agreed to obtain a robust implementation attaining to this particular goals:
    \begin{itemize}
    \item<2-> Finish the implementation of components (previously named Blocks and Ports).  \visible<3->{\pgfimage[height=10pt]{figures/tick}}
    \item<4-> Add a simulation backend with support for \textbf{any} signal type.\visible<5->{\pgfimage[height=10pt]{figures/tick}}
    \item<6-> Support all the synchronous process constructors in ForSyDe.\visible<7->{\pgfimage[height=10pt]{figures/tick}}
    \item<8-> Improve the error handling and reporting of the compiler.\visible<9->{\pgfimage[height=10pt]{figures/tick}}
    \item<10-> Optionally. Document the code with haddock and cabalize the project.\visible<11->{\pgfimage[height=10pt]{figures/tick}}
    \item<12-> Create a project webpage\visible<13->{\pgfimage[height=10pt]{figures/cross} Not until there's a release}
    \item<14-> Improve the VHDL backend.\visible<15->{\pgfimage[height=10pt]{figures/cross} Still not advanced support}
    \end{itemize}
 \item<16-> Additional work done
 	\begin{itemize}
	\item The project was rewritten from scratch (slightly based on the old code).
		\begin{itemize}
		\item<17-> New module hierarchy\visible<17->{\pgfimage[height=8pt]{figures/tick}}
		\item<18-> More general identifiers.\visible<18->{\pgfimage[height=8pt]{figures/tick}}
		\item<19-> 	Access to external scope of \texttt{ProcFun}s.\visible<19->{\pgfimage[height=8pt]{figures/tick}}
		\item<20-> Redesigned component API.\visible<20->{\pgfimage[height=8pt]{figures/tick}}
		\end{itemize}
	\end{itemize}
  \end{itemize}
\end{frame}

\section{Goal details}

\subsection{Components}

\begin{frame}[fragile]
  \frametitle{Components}
  %\framesubtitle{Components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
  \begin{itemize}
  \item
  Components were reimplemented from scratch, creating a more functional and intuitive API.
   \onslide<2->
  \item
  Let's see a simple example. Design a serial adder using components in 5 simple steps.
  \visible<2->{\pgfimage[width=10cm]{figures/SeqAddFour}}
  \end{itemize}
  
  
  \vspace{-0.7cm}
  \begin{overprint}
   \onslide<3>
   \begin{enumerate}[1)]
   \item Create a process function which adds one to its input 
    \begin{lstlisting}
  addOnef :: ProcFun (Int -> Int)
  addOnef = $(newProcFun [d| addOnef :: Int -> Int 
                             addOnef n = n + 1 |]
    \end{lstlisting}
    \end{enumerate}
   
   \onslide<4>
   \begin{enumerate}[2)]
   \item Create a system function corresponding to the unit adder
   \begin{lstlisting}
  addOneProc :: Signal Int -> Signal Int
  addOneProc = mapSY "addOne" addOnef
   \end{lstlisting}
   \end{enumerate}
   
   \onslide<5>
   \begin{enumerate}[3)]
   \item Subsystem definition associated to the unit adder
   \begin{lstlisting}
 addOneSysDef :: SysDef (Signal Int -> Signal Int)
 addOneSysDef = $(newSysDef 'addOneProc ["in1"] ["out1"])
   \end{lstlisting}
   \end{enumerate}


   \onslide<6>
   \begin{enumerate}[4)]
   \item Create the main system function
   \begin{lstlisting}
  addFour :: Signal Int -> Signal Int
  addFour = $(instantiate "addOne3" 'addOneSysDef) .
            $(instantiate "addOne2" 'addOneSysDef) .
            $(instantiate "addOne1" 'addOneSysDef) .
            $(instantiate "addOne0" 'addOneSysDef)
   \end{lstlisting}
   \end{enumerate}

   \onslide<7>
   \begin{enumerate}[5)]
   \item Finally, build the main system definition
   \begin{lstlisting}
  addFourSys :: SysDef (Signal Int -> Signal Int)
  addFourSys = $(newSysDef 'addFour ["in1"] ["out1"])
   \end{lstlisting}
   \end{enumerate}

\end{overprint}

\end{frame}


\begin{frame}
  \frametitle{Design Flow Using Components}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\vspace{-0.2cm}
\begin{center}
\pgfimage[height=8cm]{figures/compflow}
\end{center}

\end{frame}

\beamerdefaultoverlayspecification{<+->}

\subsection{Supporting any \texttt{Signal} type}
\begin{frame}[fragile]
  \frametitle{Supporting any \texttt{Signal} type}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
  %   for anyone how does not follow everything on the slide itself.
\vspace{-0.2cm}
\begin{itemize}
 \item Challenge: support simulating signals of any type. 
 \item<2-> How is it possible? \texttt{Typeable} and \texttt{Lift} constraints. 
    \begin{lstlisting}
class Typeable a where
  typeOf :: a -> TypeRep

toDyn :: Typeable a => a -> Dynamic

class Lift t where
  lift :: t -> Q Exp
   \end{lstlisting} 

   \begin{lstlisting}
delaySY :: (Typeable a, Lift a) => 
            ProcId -> a -> Signal a ->  Signal a 
   \end{lstlisting}

\item<3-> What about the instantiation boilerplate code? 
 \begin{itemize}
  \item<4-> GHC supports automatic derivation of \texttt{Typeable}
  \item<4-> I Improved Igloo's Lift library (GHC 6.10 won't need it, i.e. \texttt{instance Data a => Lift a} will probably be included).
   \begin{lstlisting}
data LogicVal = High | Low deriving (Eq, Typeable)
$(deriveLift1 ''LogicVal)
   \end{lstlisting}
 \end{itemize} 
\end{itemize}
\end{frame}

\subsection{The simulation backend}

\begin{frame}[fragile]
  \frametitle{The simulation backend}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
\begin{itemize}
 \item A new sequential simulation backend has been implemented
\begin{center}
    \pgfimage[height=4cm]{figures/Simulate}
\end{center}
 \item<2-> It detects combinational loops (i.e. loops not including a \texttt{delaySY} process).
   \begin{itemize}
    \item The detection was impossible with the previous stream-based signal implementation.
    \end{itemize}
  \item<3-> Completely usable but still not optimal:
  \begin{itemize}   
   \item Due to some implementation problems, simulation is strict and its efficiency could be improved.
  \end{itemize}  
  \end{itemize}
\end{frame}



\subsection{Full support of the Synchronous Process Library}

\begin{frame}
  \frametitle{Full support of the Synchronous Process Library}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
 \begin{itemize}
 \item  All ForSyDe synchronous process and process constructors are supported in the frontend and the simulation backend.
  \begin{itemize}
  \item Even polymorphic processes work (big thanks to Oleg Kisleyov for his help at haskell-cafe) 
  \end{itemize}
 \item<2-> The Equalizer was ported to the new compiler API and
 is correctly simulated
 \item<3-> The frontend already supports supplying identifiers for each process (detection of duplicates is not implemented yet)
 \item<4->  Error reporting was improved
 \begin{itemize}
 \item GHC 6.10 will provide line information to Template Haskell, allowing to make error reports more useful.
 \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Cabal and Haddock}

\begin{frame}[fragile]
  \frametitle{Cabal-ready and Haddock-tagged}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
 \begin{itemize}
 \item<1-> By the time the library was rewritten, all modules were haddock-tagged.
 \item<2-> Thanks to the recent release of Haddock 2.0 (which is embedded in GHC), using Template Haskell is not a problem anymore.
 \item<3-> The package was cabalized. Configuring the package, building it, generating the documentation and installing it is as easy as typing:
   \begin{lstlisting}
$ cd ForSyDe; ./Setup.hs configure; ./Setup.hs build; \
              ./Setup.hs haddock; ./Setup.hs install
   \end{lstlisting}  
 \end{itemize}
\end{frame}

\subsection{Improved VHDL backend}

\begin{frame}
  \frametitle{Improved VHDL backend}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
 \begin{itemize}
 \item Not ready yet and currently broken.
   \begin{itemize}
    \item Got the point of supporting components, \texttt{Bool},   \texttt{Int} signals, and only basic process constructors.
   \item Currently working on a common API for translation backends.
   \end{itemize}
 \item Reasons
   \begin{itemize}
   \item Underestimated the task cost.
   \item Time: stuck in various Template Haskell bugs and working in the frontend and the simulation backend.
   \item Design problems still unsolved: 
      \begin{itemize}
      \item What types to support? How? i.e. Vectors, Floating point types.
      \item How to support user-defined types? (\texttt{Data} typeclass constraints in process constructors could be an option).
      \item What Haskell subset should be allowed inside \texttt{ProcFun}s?
      \end{itemize}
   \end{itemize}     
 \end{itemize}
\end{frame}

\section{Additional work}
\subsection{Accessing the external scope within \texttt{ProcFun}s}

\begin{frame}[fragile]
  \frametitle{Accessing the external scope within \texttt{ProcFun}s}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
 \begin{itemize}
 \item Previously, \texttt{ProcFun}s had to be selfcontained.
  \begin{itemize}
  \item i.e. The translation backends didn't have a way of accesing the external scope of a \texttt{ProcFun}, for instance:
  \end{itemize}
   \begin{lstlisting}
 $(newProcFun [d| filterer :: (a -> Bool) -> a -> AbstExt a
                  filterer pred val = 
                    if pred val then Prst val else Abst  |])
   \end{lstlisting}    
 \item<2-> New functions allow to pass parameters without loosing encapsulation:
    \begin{lstlisting}
defArgVal :: (Lift a, Typeable a) => ProcFun (a -> b) -> a 
          -> ProcFun b
defArgPF :: ProcFun (a -> b) -> ProcFun a -> ProcFun b
   \end{lstlisting} 
\item<3-> Implementation of \texttt{filterSY}
\begin{lstlisting}
filterSY id pred = mapSY id (filterer `defArgPF` pred) 
\end{lstlisting}
  \begin{itemize}
  \item Not a primitive anymore
  \end{itemize}
 \end{itemize}
\end{frame}

\section{Lessons Learned}

\begin{frame}
  \frametitle{Lessons learned}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
 \begin{enumerate}
 \item Template Haskell is in a less mature state than I expected
  \begin{itemize}
  \item Reported $\approx$ a dozen bugs/feature requests during this stage.
  \item I got stuck finding workarounds for many of them. 
  \item Fortunately the GHC team is more open and understanding than I can even wish.
  \item All the reported problems are likely to be fixed for GHC's next major release (GHC 6.10)
  \end{itemize}
  
 \item E-mail communication should be more fluent when possible
 \begin{itemize}
  \item Quick feedback is extremely important!
 \end{itemize}
 \end{enumerate}
\end{frame}

\section{Specific topics to discuss}

\begin{frame}
  \frametitle{Specific issues to discuss}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
 \begin{itemize}
 \item Technical issues
 \begin{itemize}
  \item VHDL backend
   \begin{itemize} 
    \item What primitives types to accept? 
    \item Custom types?
    \item What Haskell subset in \texttt{ProcFun}s?
   \item Process identifiers. Continue with current approach?
   \end{itemize} 
  \item 
 \end{itemize}
 \item Bureaucratic issues
 \begin{itemize}
  \item Release
  \begin{itemize}
    \item When should the package be released in Hackage?
    \item What version number should it carry?
    \item Name? ForSyDe vs ForSyDeStdLib
   \item License, copyright holder, maintainer e-mail.
  \end{itemize}
 \item Resources
  \begin{itemize}
  \item Darcs repository
  \item Mailing list archives
  \item Maybe use external hosting? 
    (\texttt{code.haskell.org}, Sourceforge ...)
  \end{itemize}
 \end{itemize}
 \end{itemize}
\end{frame}

\section{What's next?}

\begin{frame}
  \frametitle{What's next?}
  %\framesubtitle{Design flow using components.}
  % - A title should summarize the slide in an understandable fashion
 \begin{itemize}
 \item What should be done now?
 \item Personal proposal
  \begin{itemize}
   \item Finish the VHDL backend
   \item Move on to the new library
   \item Continue adding features
  \end{itemize}
  \item What features? With what precedence? Options:
    \begin{itemize}
     \item Graphical backend.
     \item SystemC backend.
     \item Verification backend (SMV).
     \item Graphical frontend.
     \item Transformational refinement.
    \end{itemize} 
 \end{itemize}
\end{frame}

\end{document}


